<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[2020年度总结]]></title>
      <url>%2F2020%2F12%2F31%2Fsummary_2020%2F</url>
      <content type="text"><![CDATA[又到了写年度总结的日子了，蓦然回首，发现这已经是写Blog的第四年了。较之去年，今年可谓相当高产了：12个月里产出11篇，四舍五入就是月刊了（笑。可见今年相当充实，每个月都整了新活。工作方面也已过一年，特作总结，以为归纳。 今年内容输出上最大的变化就是吹响了进军3D的号角，以完成一款俯视角3D ARPG Demo为目标，对各项技术专题展开了研究。特别在图形效果方面，由于现实的需要，已经到了不得不掌握的时候。结果没想到学习起来相当顺利，以前一直觊觎而不得的知识在现实需求的推进下顺利掌握，果然还是得知行合一呀。 当然能够如此顺利，个人想来也与前些年对这块一直觊觎的成果吧。毕竟概念的东西还是翻来覆去看过不少，只欠一次实践的机会罢了。现在想来也是颇为后悔，若是当年抽出点时间写写渲染器啥的那就更好了。不过也只是想想而已，没有明确的需求与觉悟下，只凭一时兴起是难以坚持下去的，只能把目光放在未来了。 接触这块对我来说算是进入一个新的领域，也因此有幸结识了不少朋友。通过相互交流学到了不少，增长颇多见闻。也因此让我正视以技术美术作为职业的可能性，目前按个人标准看来还是不行的：效果实践的广度仍是不足，对于DCC软件的掌握、美术工作的流程与体验还不够深刻，对渲染管线、图形原理的认识与实践也不够。总体而言感觉只是初中级水平，还有很长的路要走。 世人常言TA分程序向与美术向，尽管我并不是很认可：我认为懂美术的TA才是真的TA，而所谓程序向TA只是人才不足的权宜之计，或者是图形程序的过渡罢了。而我确实没有动力与天分去成为美术，可见若是要继续往这条路走下去的话，就得靠拢图形程序了吧。当然从现状而论，作为Gameplay程序兼职TA与策划也许是个不错的组合拳，这也算是独立制作出身的优势了吧（笑 照目前来看的话，下一年Demo的重心将会回归Gameplay，文章产出应该会少很多吧（Gameplay的东西没有经过时间的验证就没有说服力）。当然TA这块也会继续走下去，还是挺有意思的，希望能有更多结合实际的机会吧。 至于工作相关的内容限于篇幅与细节便在此略过不谈，以上便是本人的2020年度总结了，且待明年的Blog吧。 无双草泥马 2020.12.31]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[地形系统挣扎录——从Blender到Unity]]></title>
      <url>%2F2020%2F12%2F14%2Fllbn_terrain%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 之前由前篇决定场景的制作模式为Tile流，这种面片堆砌的流派对于方方正正的场景（如室内）很有效。但是对于如山地草原一般的场景就很难受了： 可能粗看下去感觉还行，实际上是不禁细看的，地形是在方方正正的基础上揉捏而成，可以在斜边处可以到明显的采样变形，且草地边缘的石边是手动暴力贴上去的，制作起来非常的耗时且嗨奴。经此一役后美术决定引入业界更通用的场景制作方案——Terrain流： 如上图所示，所谓Terrain流就是非常常见的那种在场景编辑器对模型揉揉捏捏塑形，涂涂抹抹上色的制作流派。对于制作地形复杂、贴图混杂的场景可谓相当受用。那么按理来说直接使用现有的地形编辑工具不就好了？——若是那么简单便没有本篇喽。 首先经过一番实验后发现，由于美术风格、建模习惯等因素，决定采用传统建模方式，而非这些场景编辑器惯用的揉捏平面生成高度图。如此一来这些场景编辑器便都Pass，将目光放到了传统建模软件·Blender上……于是便有了本文的副标题：从Blender到Unity。Unity版本为2019.4（URP），Blender版本为2.9。 牛刀小试 由于这波算是造轮子了，没得现有的套件可蹭，所以还是先整点最基本的实现吧。在抛开建模那块，Terrain流的贴图着色说白了就是由1张索引贴图+若干张地形贴图组成，通过工具绘制索引贴图，最终根据索引采样对应的地形贴图，实现贴图混杂的显示效果： 大致Shader实现如下： 123456789half4 Frag(Varyings input) : SV_Target&#123; half4 mask = SAMPLE_TEXTURE2D(_MaskMap, sampler_MaskMap, input.uv); half4 color1 = SAMPLE_TEXTURE2D(_TerrainMap1, sampler_MaskMap, input.uv) * mask.r; half4 color2 = SAMPLE_TEXTURE2D(_TerrainMap2, sampler_MaskMap, input.uv) * mask.g; half4 color = color1 + color2; return color;&#125; 可见实现原理并不算复杂，将贴图的每个通道（RGBA）作为贴图的透明度值显示即可，但一切才刚刚开始…… 图集 OR 纹理数组 首先第一个问题便是贴图的管理方式：根据上文代码可以看出，目前的地形贴图是一张张独立的存在。那么就会变成有多少张地形纹理就要开多少个口了，不利于环保且哈批。业界相关流行的解决方法有图集（Atlas）与纹理数组（TextureArray）两种。 所谓图集便是将各种贴图整合进一张大图里，按偏移采样，是很常见的做法： 相关的采样方法可以参考冯乐乐的地形纹理合并，大致如此： 123456789101112half4 SampleIndex(int index, half2 pos) &#123; half2 uv = frac(pos) * 0.484375 + 0.0078125; int lines = floor(index / 2); half2 uv2 = half2(index - lines * 2, lines); uv2.y = 1 - uv2.y; uv += uv2 / 2.0; half4 color = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, uv); return color;&#125; 大致思路为根据要采样的贴图索引（index），结合世界坐标的小数点(pos)，得到对应的uv坐标。其中这里的0.484375、0.0078125为采样收缩的魔法数字（0.0078125=1/128，128位图集的宽高，0.484375=0.5-0.0078125），这么做的理由与瓦片地图一致：由于贴图的密集性，线性采样两者的贴图边缘会产生混色现象，注意红色框选的部分： 为了解决这个问题，于是选择人工收缩了采样范围。但相对而言，在镜头放大后还是能看得出贴图之间并非是严丝合缝的，毕竟采样已经不连续了，算是一个不大不小的缺陷吧。 而纹理数组则是个PS4时代以来的新玩意，在Unity官方文档中明确了支持的平台，可见一般手机设备对此不见得能够支持。但我们做的是PC端便无所谓了，用起来用起来！ 纹理数组的原理很简单：一次性把多张贴图打包成新的数据，与一般贴图用法无异，只是采样的API有所不同，需要指定index。这么一来可就我可就不困了呀，拿先前的Shader改造下对比： 123456789half4 Frag(Varyings input) : SV_Target&#123; half4 mask = SAMPLE_TEXTURE2D(_MaskMap, sampler_MaskMap, input.uv); half4 color1 = SAMPLE_TEXTURE2D_ARRAY(_BaseMap, sampler_BaseMap, input.uv, 0) * mask.r; half4 color2 = SAMPLE_TEXTURE2D_ARRAY(_BaseMap, sampler_BaseMap, input.uv, 1) * mask.g; half4 color = color1 + color2; return color;&#125; 较之图集那花里胡哨的采样方式真是爽快多了，而且还没有合缝问题。美中不足在于Unity并没有提供直接的创建纹理数组的方法，需要自己撸一个，限于篇幅便不再列出，给个参考便可。 传统UV OR 世界坐标 从图集的采样算法可以看出是不便使用模型本身的uv的，而是要用世界坐标作为驱动代替。但现在决定使用纹理数组，那么这便成了个问题。使用传统UV采样在多数情况下并没有什么问题，但是在这种情况下便暴露了： 如图所示，山峰出现了很夸张的拉伸现象，这是UV划分精度不足导致的（整个山峰的面采样了一张贴图），对此可以通过划分UV解决，但规模一旦上去后，这会给美术带来不小的负担。那么来对比下世界坐标的情况： 虽然在采样上有点小瑕疵，但的确是好多了。由于世界坐标是三维的，而纹理采样是二维的。若是只按某两个维度进行采样，在某些面必然会发生问题： 于是我们可以根据法线判定面的朝向以决定使用世界坐标的哪两个轴，但在某些斜面下实际上需要用到两个平面维度的结果混合。于是干脆一步到底，根据法线三个轴的值决定三个平面维度（zy、xz、xy）的混合度，是为三向贴图（Tri-planar Mapping）： 123456789101112half4 Frag(Varyings input) : SV_Target&#123; half3 weight = pow(abs(input.normal), _BlendSharpness); // _BlendSharpness可增大混合效果 weight = weight / (weight.x + weight.y + weight.z); // 质量守恒 half4 color = 0; color += SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, input.position.zy) * weight.x; color += SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, input.position.xz) * weight.y; color += SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, input.position.xy) * weight.z; return color;&#125; 但由上图也看得出来，在某些情况下它并非是完美的（或者没必要）。且性能消耗大，采样次数翻了三倍。由此可见两者皆有其使用场合，故决定通过分支开关控制两者的切换。当然最理想的情况自然是让美术好好分UV（ 界限突破 讨论了以上两个问题后，还有一个很明显的问题：若是使用RGBA四个通道代表四种地形贴图的透明度，那么首先可使用的地形贴图数量就太少了，并且需要同时对这四张贴图进行采样，若是加上三向贴图更是达到了恐怖的12次采样！这绝对是不可接受的，仔细想来，实际上多数情况只会有两种贴图混合，加上Demo的像素风格更是不会发生太多的混合现象。那么便可以改成同一像素最多采样两种地形贴图的方案了： 123456789half4 Frag(Varyings input) : SV_Target&#123; half4 mask = SAMPLE_TEXTURE2D(_MaskMap, sampler_MaskMap, input.uv); half4 color1 = SAMPLE_TEXTURE2D_ARRAY(_BaseMap, sampler_BaseMap, input.uv, mask.r); half4 color2 = SAMPLE_TEXTURE2D_ARRAY(_BaseMap, sampler_BaseMap, input.uv, mask.g); half4 color = lerp(color1, color2, mask.b); return color;&#125; 如上所示，新方案下RG通道代表地形贴图的索引值，B通道作为两者颜色的混合度（255则完全显示color1，反之亦然），如此便可只用到三个通道的前提下支持多种地形贴图，同时只采样2次，哪怕加上三向贴图也算在可以接受的程度了。 在Blender的战斗 以上Shader看着简单，到了Blender这边的Shader开发那麻烦可大了。由于可视化的因素，我们需要用特定颜色代表对应的索引值，且要选择通道明确的颜色，也就是：黑（RGB）、红（R）、绿（G）、蓝（B）、黄（RG）、紫（RB）、青（GB）。鉴于黑色的特性，将之作为地形的默认底色。其余颜色根据深浅与黑色进行混合。其中的关键便是如何识别单/双通道颜色的有效性，对此我选择双通道颜色值必须相差小于10才有效，反之则是值大的通道有效。 这看着也不算很复杂，可恶的是Blender的新版渲染引擎Cycles并不支持代码形式的Shader（OGL），只支持连连看。而老板渲染引擎Eevee只支持在渲染模式下看到结果，这样便达不到实时修改预览的效果了。于是乎化身为毛线团战士： 主要Blender内置的节点并不支持分支判断，于是只能老老实实把每种颜色的处理都弄上去加一块，使用比较节点取得0值来屏蔽不该显示的部分。除此之外便是贴图资源不能作为参数值存在，只能老老实实创建贴图节点在外头进行填写，可由于三向贴图的加入，每种贴图还得手动填三次，算上总和一共是21种了…… 不过所幸效果还是不错的，以后再有这样也许可以考虑看看源码了…… 脚本转换 在Blender绘制的贴图还无法直接用于游戏，毕竟游戏可顶不住这样的Shader写法。于是便需要一Python脚本将之转换为游戏Shader可直接食用的贴图。实现大致思路与Blender Shader无差，只是在CPU端便可暴力条件判断了，爽歪歪： 1234567891011121314151617181920212223242526def convert_index(color): a = get_max_channel(color) b = get_mid_channel(color) if a == 0: return INDEX_MAP['black'], 0, None, None # Black if a - b &lt; 10: v = a + b alpha = (a + b) // 2 if v == color[0] + color[1]: return INDEX_MAP['yellow'], alpha, 0, 1 # Yellow elif v == color[0] + color[2]: return INDEX_MAP['purple'], alpha, 0, 2 # Purple elif v == color[1] + color[2]: return INDEX_MAP['azure'], alpha, 1, 2 # Azure else: if a == color[0]: return INDEX_MAP['red'], a, 0, None # Red elif a == color[1]: return INDEX_MAP['green'], a, 1, None # Green elif a == color[2]: return INDEX_MAP['blue'], a, 2, None # Blue return INDEX_MAP['black'], 0, None, None # Black 当然为了图片的可视化，索引不会按照原值输出，而是return math.floor(index * 255 / 6)，自然游戏Shader那边也要做相应解码处理。 除此之外，由于索引贴图的设计因素无法达到传统素材做法的线性采样效果，只能如二图那般马赛克： 为了减少这种马赛克的感觉，便使用脚本判断像素周边有多少不相同索引的像素，以此按比例减少透明度： 另外诸如设置图片输出宽高，指定颜色对应的索引值等功能限于篇幅在此便不展开了。 后记 本篇的内容有点超乎我想象，也到了收获的时候了，最后来看看成果吧： 在本次地形系统的调研中断断续续挣扎了一个半月，可谓把各种坑都踩了一遍。属实离谱，当然也与最近项目较忙有关。目前看来效果与先前并无太大差距，主要在创作模式多了新的道路，相关美术效果仍会持续优化，期待由此开端最终会演进到怎样的程度呢？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Visual Effect Graph魔改录]]></title>
      <url>%2F2020%2F10%2F08%2Fveg%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 前文提到关于粒子想实现一些东西，本篇便来还愿了。Demo使用的粒子系统并非传统的Particle System，而是基于GPU的Visual Effect Graph，下文简称VEG。 VEG的问题与近年来Unity新出的模块一样：有些功能就做了个壳没下文了，我需要的光照探针功能便是如此。尽管VEG在编辑器做了支持，但实际上功能是没实现的： 所幸Unity近年来的模块有个好处：开源，通过Package Manager下载的模块其本身已经是开源可修改的，若是对其进行一番研究搞不好就能自己实现想要的功能，不必再苦等官方？答案是没错的，我如愿以偿为VEG增加了三个功能，并将之开源了。 研究 根据上图可以发现，VEG特效的构成实际上就是Compute Shader + 一般Shader，它们是由VEG编辑器生成的，双击可查看生成后的代码。由此可见，VEG实际上与Shader Graph差不多，都是通过编辑器进行创作，最后生成相应的代码。 由于先前的经验，这类源码的入手点自然是找到编辑器定义属性的地方。比如设置Shader效果的Output部分，顺藤摸瓜便很快找到了： 以此类推，便找到了生成Shader的相关处： 如此路线便打通了，以上得到了两个重要的信息：每个不同的Output类型（Quad、Cube、Mesh……）都会有对应的Shader模板，表示我们加料时也要考虑到多种类型的情况。其次是区分了Legacy与Universal两个文件夹，可见分别对应Built-in与URP管线，毕竟他们使用的Shader库并不相同。如此VEG能在老管线使用，并且在HDRP有新功能就能理解了。 接受阴影 目前对于VEG最迫切需要的功能便是接受阴影了，无论实时阴影还是光照探针，VEG目前都是没有的。好在按照上文的路线通读一番后，发现追加接受阴影还是蛮容易的。 顺着上文继续走下去，看到了主Pass下有个名为VFXApplyColor的插入片段在各类型的主Pass都有用到，可见是通用的着色过程。那么在这里加入阴影着色正好： 通过搜索其他函数的出处找到了Shaders/RenderPipeline/Universal/VFXCommon.hlsl，到了这里便是熟悉的Shader编写环境了，Include的文件都是URP那套，写就完事了： 12345678float4 VFXApplyShadow(float4 color, float3 posWS) &#123; float4 shadowCoord = TransformWorldToShadowCoord(posWS); Light mainLight = GetMainLight(shadowCoord); color.rgb *= mainLight.color * mainLight.distanceAttenuation * mainLight.shadowAttenuation; return color;&#125; 当然这函数还不能直接用，根据观察其他函数还会在Shaders/VFXCommonOutput.hlsl针对VEG的环境做一层封装然后写到VFXApplyColor里即可： 123456789101112float4 VFXApplyShadow(float4 color,VFX_VARYING_PS_INPUTS i)&#123; #if USE_RECEIVE_SHADOWS #if defined(VFX_VARYING_POSWS) return VFXApplyShadow(color, i.VFX_VARYING_POSWS); #else return VFXApplyShadow(color, (float3)0); //Some pipeline (LWRP) doesn't require WorldPos #endif #else return color; #endif&#125; 当然还要提供阴影相关的multi_compile，搜索代码得知加在VFXPassForwardAdditionalPragma片段，然后就可以看效果啦： 光照探针 接受实时阴影算是完成了，但还要考虑到烘焙阴影的情况，于是对于光照探针的支持也要考虑到。VEG关于光照探针的外围支持已经完备（根据光照设置、探针设置开启相关KEYWORD），欠缺的只是Shader相关的部分。 在不考虑GI，按照我在模型渲染一样的做法的前提下，只需要在VFXApplyShadow加点料即可： 123456789101112float4 VFXApplyShadow(float4 color, float3 posWS) &#123; float4 shadowCoord = TransformWorldToShadowCoord(posWS); Light mainLight = GetMainLight(shadowCoord);#if defined(_MIXED_LIGHTING_SUBTRACTIVE) mainLight.distanceAttenuation = lerp(GetMainLightShadowStrength(), 1, saturate(mainLight.distanceAttenuation));#endif color.rgb *= mainLight.color * mainLight.distanceAttenuation * mainLight.shadowAttenuation; return color;&#125; 与之前的做法一样，distanceAttenuation在光照探针下会变成光照计算的着色值，将之锁定在阴影强度-1之间即可。然后烘焙阴影，设置特效组件开启光照探针即可看到效果了： 比较遗憾的是，光照探针的计算是以GameObject为准的，而非以每个粒子为准，这也是没办法的事，只能尽量避免露馅了。 关于阴影还剩最后一个点没有做：在编辑器的开关设置，这个模仿其他属性添加变量，并在VFXParticleOutput.cs的additionalDefines变量里添加相关KEYWORD，最后在Shader里做判定即可： 水面问题 目前粒子特效在水面上显示会出现很明显的层次错误： 火焰实际上并没有进入水里，但是看着却变蓝了。这是因为水面的渲染时机在所有对象之后，并使用CameraColorTexture进行显示。而此时火焰已在Texture里了，于是与水重叠的部分便被水渲染处理了。 基于这个问题可以很迅速的想到解法：利用RenderFeature的RenderObjects可以新建渲染批次，并将粒子主Pass的LightMode改为新的批次即可： 试了下效果，问题的确解决了，但是…… 但是水里的火焰消失了，这也是当然的，毕竟在水面渲染之前，火焰还没渲染呢。进一步思考后想到了个绝妙的方案：为粒子新增一个与主Pass一模一样的Pass，也就是目前的ParticlePost，保留原本的主Pass，将LightMode还原。当然只是如此的话会出现一个粒子渲染两次重叠起来的情况，而我们可以让ParticlePost只在与水面重叠时显示，这样便可解决重叠问题了。 为此我们要用上模板测试，让水面写入特定的模板值，然后在ParticlePost做判定（假设水面写入值为2）： 限于篇幅，关于添加Pass的做法还请自行查阅源码。看看效果吧： 很棒很棒，这下算是解决粒子与水面的问题了。尽管在水面时事实上是有重叠的，看着效果还行就凑合吧。由此延伸可以说是半透明对象与水面的一种解决方案了。 最后是编辑器相关，只能写死数值显然是不好的，这里我使用了VEG提供的定义代码段功能，在VFXParticleOutput.cs的additionalReplacements变量添加，并在模板里调用即可： 后记 VEG较之传统粒子最大的优势便是运算放在GPU以及开放源码可供修改了吧，可惜必须在支持Compute Shader的设备上才能运作。这一点注定它在手游里很难用得上了，只能期待老手机早日淘汰了……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在URP实现水面效果]]></title>
      <url>%2F2020%2F09%2F06%2Flbbn_water%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 Demo的场景也到了做水面的时候了，在涉及技术之前首先要确定的是美术表达：当然大体上也就是卡通水与写实水的抉择，最终决定是做出《伊苏：起源》那样的写实水（注重扭曲、透视、无形变），并在此之上现代化。 上色 首先我们先找个小池子作为试验场地——这样利于观测，那么很显然密室场景的熔岩就可以暂退了： 水面的本质很简单，它就是个面片而已（不论海浪）。最直接的第一步自然是上色： 上色之后自然是透视，把材质设置为Transparent，调整下透明度： 很好，其实对于一些游戏的低画质，这个水面已经是成品了。当然这也太捞了，继续演进—— 扭曲的准备 对于水面效果的重点自然是扭曲了，处于水中的部分都会因为光的折射而变化。当然我们实际做起来并不会遵照这些大道理，看着是那么回事就得了（图形学第一定律）。最简单的做法自然是把对象渲染完毕后的画面截获，水面材质再选取合适的画面部分显示，并基于此加入扭曲—— 对于Built-In管线而言，想做到这点使用GrabPass即可，这方面的实现在《Unity Shader入门精要》已有详细做法。可是由于其设计不符合SRP的哲学，在URP已经被毙了，于是我们只能另寻他法了。 当然实际上也没那么麻烦，思想已经有了，找到对应的实现方法即可：对象渲染完毕后的画面生成在URP可以通过管线设置文件勾选Opaque Texture实现，然后便可在Shader声明_CameraColorTexture调用。 当然仅仅如此会有个问题：此图的生成时机是渲染所有非透明（Opaque）对象后，对于具有透明度的对象（Transparent）的渲染时机是在此之后的，这样水面里将会看不到Transparent对象了。对于此有两个解决方案： 修改源码，将生成时机调到Transparent渲染之后。 利用RenderFeature自行在合适的时机生成画面Texture。 经过项目实际情况的考虑，我选择修改源码（具体修改在MyURP）。在Frame Debugger可以看到渲染时机已经变为Transparent之后了： 做到这步只能算是准备好了子弹，接下来还要制造枪械：由于自带的Shader Pass的渲染时机并不在生成_CameraColorTexture之后，所以我们需要利用RenderFeature构建个渲染时机生成之后的环节。这里直接使用URP自带的Render Objects即可满足： 如此只要Shader里Tag名为Grab的Pass，都将会在此RenderFeature进行渲染。接下来便是完成Shader： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859SubShader&#123; Pass &#123; Tags &#123; "LightMode" = "Grab" &#125; Blend [_SrcBlend][_DstBlend] ZWrite[_ZWrite] Cull [_Cull] HLSLPROGRAM #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma target 2.0 #pragma vertex Vert #pragma fragment Frag #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl" CBUFFER_START(UnityPerMaterial) half4 _Color; CBUFFER_END TEXTURE2D(_CameraColorTexture); SAMPLER(sampler_CameraColorTexture); struct Attributes &#123; half4 positionOS : POSITION; &#125;; struct Varyings &#123; half4 positionCS : SV_POSITION; half4 screenPos : TEXCOORD0; &#125;; Varyings Vert(Attributes input) &#123; Varyings output; VertexPositionInputs vertexInput = GetVertexPositionInputs(input.positionOS.xyz); output.positionCS = vertexInput.positionCS; output.screenPos = ComputeScreenPos(output.positionCS); return output; &#125; half4 Frag(Varyings input) : SV_Target &#123; half3 color = SAMPLE_TEXTURE2D(_CameraColorTexture, sampler_CameraColorTexture, input.screenPos.xy / input.screenPos.w); return half4(_Color.rgb * color, _Color.a); &#125; ENDHLSL &#125;&#125; Shader实现与一般形式十分相似，主要在于用上了_CameraColorTexture以及ComputeScreenPos函数，看看效果先： 看得出效果还是有所不同的，毕竟现在水面显示的不再是一层半透明蓝色了，而是原有画面的基础上调色。现在万事俱备，只欠东风了—— 扭曲的实现 实现扭曲我们需要一张表达水面的法线贴图，或者噪声贴图也行。本质上是偏移UV，以产生扭曲的结果。我选择使用法线贴图，因为后续也有用到。 水面法线贴图的生产我并不了解，目前是随便找张不规则图形的基础上使用Unity自带的Create from Grayscale生成的，效果居然还不错： 应用起来也很简单，获取法线贴图的xy数据加到screenPos.xy即可。当然仅此而已的话水面是不会动的，所以我们还可以加个与时间挂钩的偏移值，以推动法线贴图的uv，便可产生动起来的效果： 1234567891011half4 Frag(Varyings input) : SV_Target&#123; half2 speed = _Speed * _Time.y * 0.01; half3 bump = UnpackNormal(SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, input.uv.zw + speed)).rgb; half2 offset = bump.xy; input.screenPos.xy += offset * input.screenPos.z; half3 color = SAMPLE_TEXTURE2D(_CameraColorTexture, sampler_CameraColorTexture, input.screenPos.xy / input.screenPos.w); return half4(_Color.rgb * color, _Color.a);&#125; 不错不错，对于某些游戏而言，到了这步也算完成了。但还不够—— 着色 目前有一个很明显的不足：虽然有了扭曲，但水面还是平平的一片蓝色，显然是缺乏明暗的体现。此时先前的法线贴图便可再次派上用场了：结合法线来做漫反射（Diffuse）效果。当然我们还不能直接使用取得的法线，还得将其转换至世界空间才行。 1234567891011121314151617181920212223242526272829Varyings Vert(Attributes input)&#123; ... VertexNormalInputs normalInput = GetVertexNormalInputs(input.normalOS, input.tangentOS); half3 viewDirWS = GetCameraPositionWS() - vertexInput.positionWS; output.TtoW0 = half4(normalInput.tangentWS.x, normalInput.bitangentWS.x, normalInput.normalWS.x, viewDirWS.x); output.TtoW1 = half4(normalInput.tangentWS.y, normalInput.bitangentWS.y, normalInput.normalWS.y, viewDirWS.y); output.TtoW2 = half4(normalInput.tangentWS.z, normalInput.bitangentWS.z, normalInput.normalWS.z, viewDirWS.z);&#125;half4 Frag(Varyings input) : SV_Target&#123; ... // 书接上文的bump bump = normalize(half3(dot(input.TtoW0.xyz, bump), dot(input.TtoW1.xyz, bump), dot(input.TtoW2.xyz, bump))); Light light = GetMainLight(); ... color = Diffuse(color, light.direction, bump);&#125;half3 Diffuse(half3 color, half3 lightDir, half3 normal)&#123; half NDotL = dot(normal, lightDir) + 0.5 * 0.5; return color * NDotL;&#125; 这里漫反射用的是半兰伯特（Half-Lambert），这是为了保证水面的亮度足够，看看效果： 嗯，有点味道了。再加个高光看看吧： 1234567891011half3 Specular(half3 color, half3 lightDir, half3 viewDir, half3 normal)&#123; half3 halfVec = normalize(lightDir + viewDir); half NdotH = dot(normal, halfVec); NdotH = saturate(NdotH); half v = pow(NdotH, _Smoothness); v *= _SpecularStrength; return color + color * v;&#125; 越来越有味了，不过感觉这种高光不够突出光点，加个Step试试： 123half v = pow(NdotH, _Smoothness);v = step(_SpecularRamp, v);v *= _SpecularStrength; 不错不错，就这样吧，到实际场合看看。 反射 目前的效果如上，总的来说算是OK了，但感觉还是差了点什么……没错，就是反射。起初我很自然而然的脑补认为要让周边的岩石草木投射在水面，为此我尝试了各种方案（反射探针、反射摄像机、平面反射……）都不满意，最终发现这纯属脑补了。实际由于视角原因是达不到那样的效果的，能够反射的内容基本会与折射重叠。醒悟之后发现最合适的反射内容只有纵身跳入的人物以及天空罢了：前者的出现场合太少了，对于后者与其用各种反射手段，还不如直接弄张天空贴图完事。 123456789101112half4 Frag(Varyings input) : SV_Target&#123; ... half3 texColor = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, input.uv.xy + speed); half3 color = lerp(1, texColor, _Fresnel); color = Diffuse(color, light.direction, bump); color *= SAMPLE_TEXTURE2D(_CameraColorTexture, sampler_CameraColorTexture, input.screenPos.xy / input.screenPos.w); color = Specular(color, light.direction, viewDir, bump); return half4(_Color.rgb * color, _Color.a);&#125; 弄了张天空贴图，结合扭曲所用的偏移值进行uv移动，使用_Fresnel控制反射与折射的比例。注意这里的_Fresnel仅仅是个0-1的参数，并非是真正的菲涅耳系数（由于视角关系根本用不到）。来对比下吧： 这样的假反射在美术上的意义主要是能让水的颜色没那么单调，并且由于贴图是移动的，也带来了更多的动感。 后记 最后加上点互动特效，有那么点意思了： 在加这波粒子特效时也遇到了不少问题，也多了一些想要实现的东西。限于篇幅只能留待日后了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在Demo实装光照烘焙与探针]]></title>
      <url>%2F2020%2F08%2F02%2Flbbn_baked%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 Demo目前的实时光影虽已完成，但考虑到不同的配置设备，还是得做出不同档次的光影方案。那么烘焙光照（Lightmapping）与光照探针（Light Probes）就免不了了。本文将结合项目实际需求，讲述遇到的问题及解决方案。项目引擎版本为2019.4，渲染管线为URP。 初步的烘焙 首先要做的自然是对Shader增加光照烘焙与探针的支持，照抄URP的SimpleLit Shader即可。大致要点如下： Shader添加multi_compile：LIGHTMAP_ON与_MIXED_LIGHTING_SUBTRACTIVE，这表示Shader会参与光照贴图与混合光照 顶点着色器参数添加half2 lightmapUV : TEXCOORD1;，这是光照贴图的UV 片元着色器参数添加DECLARE_LIGHTMAP_OR_SH(lightmapUV, vertexSH, 1);，这是URP自带的宏，根据LIGHTMAP_ON决定配置光照烘焙或探针的参数（lightmapUV or vertexSH），最后的参数1决定是第几个TEXCOORD 在顶点着色器调用OUTPUT_LIGHTMAP_UV(lightmapUV, lightmapScaleOffset, OUT)与OUTPUT_SH(normalWS, OUT)宏，它们将根据情况配置lightmapUV与vertexSH 在片元着色器对光照贴图或探针进行取色（SAMPLE_GI(lmName, shName, normalWSName)），最后将之加入到着色环节即可 若是想要烘焙模式下也能接受实时阴影，记得调用MixRealtimeAndBakedGI函数 总的来说都封装好了，照着拼凑而已。那么事不宜迟，直接按照默认的烘焙配置整个看看，记得要将GameObject的Static里的Contribute GI勾选方可参与烘焙： 看着似乎还不错，那么对比下实时看看吧： 这么一看还是有不少差距的，必须要让烘焙与实时的效果高度接近才行呐—— ShadowMask 经过与烘焙设置一番斗智斗勇后，我发现我要的仅仅是让阴影烘焙，以节省阴影的运算罢了。什么全局光照、烘焙自带的着色等等都是不需要的。为此我尝试过不少骚操作：生成光照贴图后进行二值化处理、直接在Shader对烘焙色进行处理等……可惜这些方案都只是治标不治本，要么在流程上繁琐，要么性能不佳，要么无法应对所有情况。最终我把目光放在了烘焙三模式之一的ShadowMask，它将单独生成阴影贴图，那么若是我只用它，抛弃光照贴图，便可达到目的了。 不幸的是，URP并没有支持ShadowMask，官网显示仍处于In research状态。幸好网上有其他人做了实现ShadowMask的教程，顺便也学习了一波可编程渲染管线（SRP）的基础知识。经过研究发现，ShadowMask的添加并不复杂，甚至可以说是URP主动将之关闭了（严重怀疑是故意拖到后面做，显得有活干）。当然这么干了之后就表示需要维护自己的URP版本了，顺便将之开源了。 SRP本质上是开放了一个可供用户定制的表层，多数核心功能还是封装好的。ShadowMask也不例外，其生成附属于烘焙模块。我们要做的只是添加一些设置，以及相应的Shader支持罢了： 12345678// 添加Shadowmask字段以让界面开启选项mixedLightingModes = SupportedRenderingFeatures.LightmapMixedBakeModes.Subtractive | SupportedRenderingFeatures.LightmapMixedBakeModes.IndirectOnly | SupportedRenderingFeatures.LightmapMixedBakeModes.Shadowmask// 添加Shader关键字，以决定是否启用功能public static readonly string MixedLightingShadowmask = "SHADOWS_SHADOWMASK";// 根据条件设置相应的Shader关键字CoreUtils.SetKeyword(cmd, ShaderKeywordStrings.MixedLightingShadowmask, renderingData.lightData.supportsMixedLighting &amp;&amp;m_MixedLightingSetup == MixedLightingSetup.ShadowMask); Shader方面要做的调整也不多，URP本身自带ShadowMask的贴图变量TEXTURE2D(unity_ShadowMask);，其UV与光照贴图一致，复用即可。记得在Shader添加multi_compile SHADOWS_SHADOWMASK以判别是否处于ShadowMask模式下。 12345678910#if defined(SHADOWS_SHADOWMASK) &amp;&amp; defined(LIGHTMAP_ON) // ShadowMask贴图只有R通道 half shadowMask = SAMPLE_TEXTURE2D(unity_ShadowMask, samplerunity_ShadowMask, lightmapUV).r; // 不超过光照Strength值 shadowMask = LerpWhiteTo(shadowMask, GetMainLightShadowStrength()); // 加入到阴影着色中 light.shadowAttenuation = min(light.shadowAttenuation, shadowMask);#endif 大致要做的事情就这么多，烘焙设置除阴影方面外，能怎么快就怎么设置（反正也用不上光照贴图了），一般来说需要注意的有Bounces要设为1，不然阴影会不完整。Flitering将对阴影贴图做边缘柔和处理，Lightmap Resolution与Lightmap Size决定阴影质量，参考如下： 另外需要注意的是，阴影精度很大程度上取决于模型的大小，因为一个模型只能有一张光照/阴影贴图，在贴图大小定死上限的前提下，模型越大贴图的解析度自然越低。那么来看看效果吧，图一为实时，图二为烘焙： 效果可以说是高度接近了，干掉了光照贴图后着色变得完全一致，阴影贴图在合理的设置下也达到了高度接近实时的效果。坡肥！ 光照探针 现在虽然实现了高度接近实时的阴影烘焙，但显而易见，当人物走向阴影处便会是这样的结果： 在某些游戏也许不太理会这种现象，但这也太捞了，光照探针便是为了解决这个问题而生的。通过在场景布置探针，将会根据动态对象附近的探针取色决定明暗度： 光照探针如果要手动布置那实在是太麻烦了，于是我使用了这个插件，通过简单的设置暴力的去平铺一波： 根据官方文档说法，探针数量与性能成反比（但越多越精确）。但此插件平铺并不会把探针置于模型内部，以及对比了下《使命召唤手游》的光照探针，感觉还行： Shader方面没什么要改的，在URP获取光照函数GetMainLight()本身自带了对光照探针的着色处理（附加在light.distanceAttenuation中），由于不需要用到全局光照，之前的OUTPUT_SH之类的都可以删了。当然有个现象需要注意下： 可以看到在暗处时实在是太黑了（也许是放弃了全局光照导致），于是我们加个约束，将暗值约束在光照Strength到1： 123#if !defined(LIGHTMAP_ON) &amp;&amp; defined(_MIXED_LIGHTING_SUBTRACTIVE) mainLight.distanceAttenuation = lerp(GetMainLightShadowStrength(), 1, saturate(mainLight.distanceAttenuation));#endif 很好，这下可以说是大功告成了！ 后记 最后演示下不同光影品质下的差别吧，分别为低、中、高： 话虽如此，可我发现目前直接把高品质光影扔到iPhone8下居然稳定59帧，太强了……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在URP实现局部后处理描边]]></title>
      <url>%2F2020%2F07%2F05%2Furp_outline%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 最近在Demo开发的过程中，遇到了一个细节问题，场景模型之间的边界感很弱： 这样就会导致玩家难以分辨接下来面对的究竟是可以跳下去的台阶，亦或是要跳过去的台阶了。我们想到的解决方法便是给场景模型加个外描边，以此区分： 整挺好，于是本文就来介绍一下实现思路。首先按照惯性我们直接采用了与人物相同的法线外扩描边，但是效果却不尽人意： 这完全就牛头不对马嘴，既然老办法不好使那就看看后处理描边吧。不过由于Demo使用的渲染管线是URP，在后处理这块与原生完全不同。于是乎再一次踏上了踩坑之旅……另附源码地址：https://github.com/MusouCrow/TypeOutline RenderFeature 经过调查发现，URP除了Post-processing之外，并没有直接提供屏幕后处理的方案。而URP的Post-processing尚不稳定（与原生产生了版本分裂），所以还是去寻找更稳妥的方式。根据官方例程找到了实现屏幕后处理描边的方式，当然它们的描边实现方式很搓，并不适合我们项目。于是取其精华去其糟粕，发现了其实现后处理的关键：RenderFeature。 RenderFeature系属于URP的配置三件套之一的Forward Renderer，你可以在该配置文件里添加想要的RenderFeature，可以将它看做是一种自定义的渲染行为，通过CommandBuffer提交自己的渲染命令到任一渲染时点（如渲染不透明物体后、进行后处理之前）。URP默认只提供了RenderObjects这一RenderFeature，作用是使用特定的材质，在某个渲染时机，对某些Layer的对象进行一遍渲染。这显然不是我们所需要的，所幸官方例程里提供了我们想要的RenderFeature——Blit，它提供了根据材质、且材质可获取屏幕贴图，并渲染到屏幕上的功能： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Shader "Custom/Test"&#123; Properties &#123; [HideInInspector]_MainTex("Base (RGB)", 2D) = "white" &#123;&#125; &#125; SubShader &#123; Pass &#123; HLSLPROGRAM #pragma vertex vert #pragma fragment frag #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl" TEXTURE2D(_MainTex); SAMPLER(sampler_MainTex); struct Attributes &#123; float4 positionOS : POSITION; float2 uv : TEXCOORD0; &#125;; struct Varyings &#123; float4 vertex : SV_POSITION; float2 uv : TEXCOORD0; &#125;; Varyings vert(Attributes input) &#123; Varyings output; VertexPositionInputs vertexInput = GetVertexPositionInputs(input.positionOS.xyz); output.vertex = vertexInput.positionCS; output.uv = input.uv; return output; &#125; float4 frag(Varyings input) : SV_Target &#123; float4 color = 1 - SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, input.uv); return color; &#125; ENDHLSL &#125; &#125; FallBack "Diffuse"&#125; 如此这般便实现了经典的反色效果，只要引入Blit的相关代码，然后在Forward Renderer文件进行RenderFeature的相关配置，并实现Shader与材质，即可生效。较之原生在MonoBehaviour做这种事，URP的设计明显更为合理。 Outline 后处理部署完毕，接下来便是描边的实现了。按照正统的屏幕后处理做法，应该是基于一些屏幕贴图（深度、法线、颜色等），使用Sobel算子之类做边缘检测。然而也有一些杂技做法，如官方例程以及此篇。当然相同的是，它们都需要使用屏幕贴图作为依据来进行处理，不同的屏幕贴图会导致不一样的效果，如上文那篇就使用深度与法线结合的贴图，产生了内描边的效果。然而我们只需要外描边而已，所以使用深度贴图即可。 深度贴图在URP的获取相当简单，只需要在RenderPipelineAsset文件将Depth Texture勾选，然后便可在后处理Shader通过_CameraDepthTexture变量获取： 有了深度贴图，那么接下来逮着别人的Shader抄就完事了——然而那些杂技做法的效果通通不行：官方的更适合美式风格，上文那篇的做法在某些场合会产生奇怪的斑点。于是只好按照《UnityShader入门精要》的写法来了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899Shader "Custom/Outline"&#123; Properties &#123; [HideInInspector]_MainTex("Base (RGB)", 2D) = "white" &#123;&#125; _Rate("Rate", Float) = 0.5 _Strength("Strength", Float) = 0.7 &#125; SubShader &#123; Pass &#123; HLSLPROGRAM #pragma vertex vert #pragma fragment frag #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl" TEXTURE2D(_MainTex); SAMPLER(sampler_MainTex); TEXTURE2D(_CameraDepthTexture); SAMPLER(sampler_CameraDepthTexture); float4 _CameraDepthTexture_TexelSize; float _Rate; float _Strength; struct Attributes &#123; float4 positionOS : POSITION; float2 uv : TEXCOORD0; &#125;; struct Varyings &#123; float4 vertex : SV_POSITION; float2 uv[9] : TEXCOORD0; &#125;; Varyings vert(Attributes input) &#123; Varyings output; VertexPositionInputs vertexInput = GetVertexPositionInputs(input.positionOS.xyz); output.vertex = vertexInput.positionCS; output.uv[0] = input.uv + _CameraDepthTexture_TexelSize.xy * half2(-1, -1) * _Rate; output.uv[1] = input.uv + _CameraDepthTexture_TexelSize.xy * half2(0, -1) * _Rate; output.uv[2] = input.uv + _CameraDepthTexture_TexelSize.xy * half2(1, -1) * _Rate; output.uv[3] = input.uv + _CameraDepthTexture_TexelSize.xy * half2(-1, 0) * _Rate; output.uv[4] = input.uv + _CameraDepthTexture_TexelSize.xy * half2(0, 0) * _Rate; output.uv[5] = input.uv + _CameraDepthTexture_TexelSize.xy * half2(1, 0) * _Rate; output.uv[6] = input.uv + _CameraDepthTexture_TexelSize.xy * half2(-1, 1) * _Rate; output.uv[7] = input.uv + _CameraDepthTexture_TexelSize.xy * half2(0, 1) * _Rate; output.uv[8] = input.uv + _CameraDepthTexture_TexelSize.xy * half2(1, 1) * _Rate; return output; &#125; float4 frag(Varyings input) : SV_Target &#123; const half Gx[9] = &#123; -1, 0, 1, -2, 0, 2, -1, 0, 1 &#125;; const half Gy[9] = &#123; -1, -2, -1, 0, 0, 0, 1, 2, 1 &#125;; float edgeY = 0; float edgeX = 0; float luminance = 0; float4 color = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, input.uv[4]); for (int i = 0; i &lt; 9; i++) &#123; float depth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, sampler_CameraDepthTexture, input.uv[i]); luminance = LinearEyeDepth(depth, _ZBufferParams) * 0.1; edgeX += luminance * Gx[i]; edgeY += luminance * Gy[i]; &#125; float edge = (1 - abs(edgeX) - abs(edgeY)); edge = saturate(edge); return lerp(color * _Strength, color, edge); &#125; ENDHLSL &#125; &#125; FallBack "Diffuse"&#125; 很棒，但是可以看到，身为一般物件的方砖也被描边了，可我们想要的只是场景描边而已——于是进入了最后的难题：对特定对象的后处理。 Mask 首先我们参考原生下的做法，利用模板测试的特性，对特定对象的Shader写入模板值，然后在后处理时根据模板值做判断是否处理，确实是个绝妙的做法——很可惜，在URP下我找不到能够生效的做法。根据上文那篇需要渲染出深度法线结合的屏幕贴图的需要，作者实现了一个新的RenderFeature：根据渲染对象们的某个Pass，渲染成一张新的屏幕贴图（可选择使用特定的材质，若不使用则是Pass的结果）。并可作为全局变量供后续的后处理Shader使用。我将之命名为RenderToTexture，这也是后处理常用的一种技术。 有了这个便有了新的想法：为所有渲染对象的Shader添加新的Pass（名为Mask），该Pass根据参数配置决定渲染成怎样的颜色（需要描边为白色，不需要为黑色）。如此渲染成屏幕贴图后便可作为描边Shader的参考（下称Mask贴图），决定是否需要描边： 注意要为Mask贴图的底色设置为非黑色，否则与底色接壤的物件会描边失败。那么见证成果吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111Shader "Custom/Outline"&#123; Properties &#123; [HideInInspector]_MainTex("Base (RGB)", 2D) = "white" &#123;&#125; _Rate("Rate", Float) = 0.5 _Strength("Strength", Float) = 0.7 &#125; SubShader &#123; Pass &#123; HLSLPROGRAM #pragma vertex vert #pragma fragment frag #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl" TEXTURE2D(_MainTex); SAMPLER(sampler_MainTex); TEXTURE2D(_CameraDepthTexture); SAMPLER(sampler_CameraDepthTexture); float4 _CameraDepthTexture_TexelSize; TEXTURE2D(_MaskTexture); SAMPLER(sampler_MaskTexture); float _Rate; float _Strength; struct Attributes &#123; float4 positionOS : POSITION; float2 uv : TEXCOORD0; &#125;; struct Varyings &#123; float4 vertex : SV_POSITION; float2 uv[9] : TEXCOORD0; &#125;; Varyings vert(Attributes input) &#123; Varyings output; VertexPositionInputs vertexInput = GetVertexPositionInputs(input.positionOS.xyz); output.vertex = vertexInput.positionCS; output.uv[0] = input.uv + _CameraDepthTexture_TexelSize.xy * half2(-1, -1) * _Rate; output.uv[1] = input.uv + _CameraDepthTexture_TexelSize.xy * half2(0, -1) * _Rate; output.uv[2] = input.uv + _CameraDepthTexture_TexelSize.xy * half2(1, -1) * _Rate; output.uv[3] = input.uv + _CameraDepthTexture_TexelSize.xy * half2(-1, 0) * _Rate; output.uv[4] = input.uv + _CameraDepthTexture_TexelSize.xy * half2(0, 0) * _Rate; output.uv[5] = input.uv + _CameraDepthTexture_TexelSize.xy * half2(1, 0) * _Rate; output.uv[6] = input.uv + _CameraDepthTexture_TexelSize.xy * half2(-1, 1) * _Rate; output.uv[7] = input.uv + _CameraDepthTexture_TexelSize.xy * half2(0, 1) * _Rate; output.uv[8] = input.uv + _CameraDepthTexture_TexelSize.xy * half2(1, 1) * _Rate; return output; &#125; float4 frag(Varyings input) : SV_Target &#123; const half Gx[9] = &#123; -1, 0, 1, -2, 0, 2, -1, 0, 1 &#125;; const half Gy[9] = &#123; -1, -2, -1, 0, 0, 0, 1, 2, 1 &#125;; float edgeY = 0; float edgeX = 0; float luminance = 0; float4 color = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, input.uv[4]); float mask = 1; for (int i = 0; i &lt; 9; i++) &#123; mask *= SAMPLE_DEPTH_TEXTURE(_MaskTexture, sampler_MaskTexture, input.uv[i]); &#125; if (mask == 0) &#123; return color; &#125; for (int i = 0; i &lt; 9; i++) &#123; float depth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, sampler_CameraDepthTexture, input.uv[i]); luminance = LinearEyeDepth(depth, _ZBufferParams) * 0.1; edgeX += luminance * Gx[i]; edgeY += luminance * Gy[i]; &#125; float edge = (1 - abs(edgeX) - abs(edgeY)); edge = saturate(edge); return lerp(color * _Strength, color, edge); &#125; ENDHLSL &#125; &#125; FallBack "Diffuse"&#125; 很棒，这下一般物件不会被描边了，局部后处理描边完成！当然随后遇到一个新的问题： 这是因为透明（Transparent）模式下的对象按照通用做法是不会写入深度信息的（为了透明时能看到模型内部），然而我们描边需要的正是深度信息，由于树叶没有写入深度信息，所以在描边时当它不存在了，于是产生了这样的结果。解决方法也好办，在透明模式也写入深度信息（ZWrite）即可，毕竟我们的透明模型不需要看到内部，一举两得。 后记 其实期间还产生了投机心理，想着把角色自带的描边给废了，统一后处理，岂不美哉？很可惜搞出来的效果始终是不满意，法线外扩 is Good，没办法喽—— 顺带一提，对于后处理的贴图创建记得将msaaSamples属性设为1，否则就会进行抗锯齿处理，那可真的炸裂……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[3D瓦片地图采坑录]]></title>
      <url>%2F2020%2F06%2F07%2Flbbn_tile%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 由于Demo的场景风格主打像素风格（这里的像素风格指具备一定精度的风格，而非时下流行的马赛克），故决定使用瓦片(Tile)地图来实现。也就是这种东西： 游戏地图将由一个个规范化的单位图片拼接而成，是为瓦片。在早期的像素风格游戏可谓相当流行，因其构造成本低（无论从技术上还是美术上），而却能灵活拼接出各种各样的地图。于是我们也打算如此，但是在3D游戏下搞瓦片地图确是罕见得很。于是便开始了采坑之旅，遂成本文。 Sprytile 首先我们想到了在3D游戏下最接近瓦片地图思想的方案：Terrain，一般3D大地图都用类似方案：对一张平面地图进行各种揉捏形成地形，并在此之上涂抹各种图素。但可惜对于瓦片地图而言未免杀鸡用牛刀了，且在各方面都不能做到最适化，遂不考虑。 其次便是Unity官方自带的2D Tilemap Editor，对瓦片方面的需求倒是满足了，可惜3D瓦片并不只是在一张平面上进行，而通过多张平面旋转组成场景未免勉强，遂放弃。 既然在Unity这边行不通，那么便考虑生产端的Blender有什么合适的插件了。果不其然找到了Sprytile，一看就明白，就是它了： 使用准备好的tile图集，划分格子，在Blender以格子为单位进行填涂，每个格子将会是一个面，支持XYZ三个平面进行，在填涂完成后可作为正常模型进行各种操作。一切看起来是那么的美好，然后一路到了游戏后…… 过滤之殇 以前篇的截图便可看出问题所在： 可以看到地板之间存在奇怪的黑线： 根据插件文档提供的Unity导出说明来看，必须要将地图贴图的过滤模式设置为Point，即邻近过滤： 嗯，黑线果然消失了。那么问题便出在图片的过滤模式了，回去复习了下纹理过滤，答案昭然若揭： 由于瓦片地图的习惯会将相关图素集成一块，形成连续的图块： 那么在线性过滤下，图块的边缘像素在采样的时候将会混进相邻图块的颜色，于是那些奇怪的黑线便是这么来的。 也许读者会认为：不用线性过滤不就得了，毕竟插件作者也是这么认为的。可惜我们做的风格并不适合用邻近过滤，那将显得与人物画风差异过大且马赛克： 细心观察上图底部，这是开启抗锯齿（MSAA）导致的。查阅资料后发现这是MSAA的特点导致，如此哪怕我们想靠邻近过滤解决也是没门……当然也考虑过更换为其他抗锯齿的方式，但是效果都不甚喜人，于是开始寻觅解决之道。 无奈的解法 首先考虑对tile图片进行下手：既然边缘会采样到相邻图块的像素，那么将它们隔开不就得了，如此： 当然这么做的话要让Sprytile有所支持才行，好在它是开源的。Blender的插件改起来也还算容易，毕竟会在界面提示标识好功能函数名。结果还是翻车了： 瓦片之间出现了奇怪的透明点，仔细一想便明白了：透明像素一样会被采样到，所以会影响到透明度。于是迅速想到下个方案：让每个图块外扩边缘1像素，这样边缘的采样只会采样到相同颜色的像素： 很不错，黑线什么的都消失了，哪怕是开着MSAA。同时美术也在Blender琢磨出了一种方法：在不做任何处理的贴图的基础上，将瓦片地图模型的UV全部缩小一点（参考值：0.96），如此便不会直接采样到边缘像素，从而以牺牲了一点点边缘效果解决了问题。 两者的效果最终是差不多的，但都是不完美的，在编辑器里便一目了然： 可以看得出，格子之间的边界可谓泾渭分明，这是因为每个格子都是独立的mesh，它们并不是作为一个整体去渲染，也就不存在视为一个整体去采样。也就无法达到真正意义上2D游戏里要达到的效果（格子之间彻底融为一体）。要这么做有两种方式：第一种是根据瓦片地图的填涂情况最终生成大贴图与新模型，但这种方式相当不优化，并且会急剧增大包体。其次是仿照以前的2D游戏做法：游戏本身使用邻近过滤渲染，最后将渲染成图进行拉伸放大（放大方式采用线性过滤），但这是牺牲画面分辨率带来的。 经过以上总结可以看出，基本不存在非常完美的解决方案，只能矮子里拔大个了：UV缩小的方案从工序上最为简单，且显示效果也能接受（没对比过原版基本看不出太多异样）。 后记 一开始我们觉得这种瓦片地图1个格子就占2个三角形，面数会不会太高了。结果在参考其他游戏的情况时发现《闪之轨迹3》的一组垃圾桶的面数…… 嗯，一组垃圾桶的面数都完爆我整个瓦片地图模型了，法老控牛逼！ 顺带一提的是，刚才提到的格子边界问题在Unity官方的2D Tilemap Editor也是存在的，只能说是瓦片地图的局限性了，好在离得远也看不太出。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Demo的卡通渲染方案]]></title>
      <url>%2F2020%2F05%2F10%2Flbbn_shading%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 本篇文章按理来说在三月便该发布了，因为插队原因延宕至今，不过好饭不怕晚，干就完了奥利给！阅读本文最好拥有一定的图形学知识，当然看个热闹也是好的。 游戏画面的风格是一开始便要定下的大事，这在古法2D主要通过素材本身及后期调色决定，没有太多文章可作。而在现代游戏（尤其是3D）则会通过Shader在原本的元素上进行加料，如通过基于物理的渲染（PBR）将模型凸显出金属、石头、布料等材质倾向。而在早期为了凸显3D模型的立体感，一般会采用经验总结出来的冯氏光照模型(Blinn-Phong)，这也是许多3D软件的默认方案，那将会让我们的模型长成这样： 嗯，这有够雕塑风的，让我想起了当初名震一时的猴赛雷，有着异曲同工之妙： 由此可见，对于讲究卡通风格的游戏，这种通用的光照模型肯定得枪毙，于是本文才会诞生。对于这类非写实方向的渲染方案，业界称之为NPR。而往下细分则是日式卡通渲染，其中佼佼者当属《罪恶装备》系列，而《崩坏3rd》也是不少人在这方面的启蒙者。当然美术这一块没有绝对的风格一致，渲染也不例外，所以Demo里的卡通渲染方案乃是个人的方案，不代表业界的标准实现与效果。 Demo基于Unity2019.3开发，渲染管线为URP7.3.1，采用直接编写Shader的方式（HLSL），将一一介绍其中要点。本文所谓的卡通效果以日式2D赛璐璐风格为准，不论厚涂之类的风格。 着色 首先我们先抛开一切：冯氏光照不好那咱们就是了。直接把贴图显示了，什么料都不要加。 123// 根据uv坐标获取对应贴图上的颜色half4 color = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, uv); 嗯，虽然很原始，但好歹没那股恶心感了，把投影也加上： 1234// 根据渲染管线提供的shadowCoord获取光照信息，并计算出投影颜色Light mainLight = GetMainLight(shadowCoord);color *= mainLight.color * (mainLight.distanceAttenuation * mainLight.shadowAttenuation); 哎呀，有了投影瞬间立体起来了，开始有《塞尔达传说：风之杖》内味了： 要加投影记得添加Pass：ShadowCaster，并且获取光照信息也需要开启一定的宏，这些并非本文重点，详情请查阅URP的Shader实现。 但只是如此还不够：颜色太鲜艳了，看久了会累。那么有两种方案：调色与着色，调色则是进行总体的颜色调节，使之不要这么鲜艳，着色则是根据模型面对光的吸收度决定明暗。这里还是选择着色：它将会增强模型的立体感。 这里说的着色其实就是冯氏光照中的漫反射（Diffuse）：当光照射到非平面的物体上，将根据与光的夹角决定吸收度（越是与光垂直的面越亮）。而在3D模型中，每个模型面都会往上发射一条射线，也就事实上构成了一条垂直于平面向量，这在数学中称之为法线（Normal）。我们可以使用向量点积(Dot)获取法线与光照方向之间的夹角，以此决定模型面的光亮程度。 123half NDotL = dot(normal, lightDir); // 计算法线与光照方向的夹角系数NDotL = saturate(NDotL); // 保证系数在0-1color *= NDotL; 啊这，这不是跟一开始差不多么？这是当然的，因为一开始便是冯氏光照的方案。其漫反射的思想其实并无问题，但原罪在于过渡太丰富了，每个模型面与光的夹角都不同，导致颜色都不同。整个模型看起来就过于立体，以至于产生了雕塑感。 而在日式2D卡通的世界里（尤其是赛璐璐），着色并不会有太详细的过渡，只是到了某个角度统一涂暗，反之为亮，最多在两者之间加点过渡而已。那么便基于此思想进行改造即可： 123456789101112half NDotL = dot(normal, lightDir); // 计算法线与光照方向的夹角系数// 根据_DiffuseRange约束系数，输出0-1的值// 由于使用了smoothstep，在接近_DiffuseRange上下限时会做柔滑处理，使之产生过渡感// _DiffuseRange的参考值为0.5, 0.7half v = smoothstep(_DiffuseRange[0], _DiffuseRange[1], NDotL);// 根据根据v的值决定输出_LightRange范围内的值// _LightRange的参考值为0.9, 1v = lerp(_LightRange[0], _LightRange[1], v);color *= v; 还不错，这下便为模型划分了明暗，并在两者之间做了过渡，这种方式称之为二值化。着色并没有采用很明显的暗色，只是想凸显一点立体感，以及让画面更柔和，不那么刺眼罢了。当然目前可以说是非常不明显了，这是有原因的，且待后续调色。 描边 接下来需要补上日式2D卡通不可或缺的一部分：描边（Outline），描边有助于划分物体，明确空间上的层次，并提供一定的风味。 关于描边的实现方式，业界主要有模型多画一遍并将边缘外扩以及屏幕后处理的方案。前者方案在日式游戏较为流行，优点在于实现简单，性能也还算过得去，缺点是必须开抗锯齿不然没眼看。后者实现方式多样，并且根据实现方式能达到不一样的效果（如一定程度的内描边），但有些更适合搭配延迟渲染（Deferred Rendering），而这代表着对显卡带宽与光照方案有要求。 另外在显示方案上也有区别，有追求任何缩放下描边大小不变的，也有自然派的。有让描边纯色的，也有要让描边根据贴图颜色决定的。本人采用的是模型外扩、自然缩放、根据贴图颜色决定的描边方案。 多显示一遍模型在Unity增加一个Pass即可，并且开启正面剔除（只显示背面，不然会干扰到正常模型）。并且在顶点着色器对模型顶点进行外扩，外扩的方向由所在模型面的法线决定。而颜色方面则在片元着色器根据贴图颜色进行置暗显示即可： 12345678910// 顶点着色器half4 viewPos = mul(UNITY_MATRIX_MV, input.positionOS); // 将顶点从模型空间转为观察空间half3 normal = mul((float3x3)UNITY_MATRIX_IT_MV, input.normalOS); // 同上，将法线转为观察空间viewPos += float4(normalize(normal), 0) * 0.0075; // 顶点沿法线外扩output.positionCS = mul(UNITY_MATRIX_P, viewPos); // 将顶点从观察空间转为裁剪空间output.uv = TRANSFORM_TEX(input.texcoord, _BaseMap); // 提取uvreturn output; 1234// 片源着色器color *= SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, input.uv); // 提取贴图颜色return color * 0.3; // 压暗 果不其然，没有抗锯齿的话就很搓，跟早期的跑跑卡丁车似的。安排一波MSAA8x： 哎，这就舒服多了，当然实际上由于小泥人的关系，4x和8x实际上看不出区别，而2x也算可以接受的效果，这么看来能耗也还好。当然关于描边实际上还有内描边这个大题，但小泥人不需要这么丰富的细节，这就很舒服。 发光 目前模型的显示还欠缺一些发光的元素，如一般头发和武器会有一些高光效果。这在冯氏光照称之为镜面光照（Specular）：本质上与漫反射一样，只是由视角方向与光照方向相加，并与法线做点积获得两者的夹角系数，如此便可实现根据摄像机与光照运动结合决定模型高光的位置。 当然仅此而已是不够的，显而易见仅此而已的话将会如漫反射一般范围很大，而高光实际上只需要一点即可。实际上会将之范围缩小： 123456half3 halfVec = normalize(lightDir + viewDir); // 将摄像头方向与光照方向相加half NdotH = dot(normal, halfVec); // 与法线点积，获取夹角系数NdotH = saturate(NdotH); // 保证在0-1half v = pow(NdotH, _Smoothness); // 缩小夹角系数的值，由于NdotH在0-1，所以pow后会变得更小，_Smoothness参考值为8-64color += color * v; // 在原有颜色的基础上叠加 与之前一样，这样的高光过渡太强了，不够卡通，将之二值化： 12345half v = pow(NdotH, _Smoothness); // 缩小夹角系数的值，由于NdotH在0-1，所以pow后会变得更小，_Smoothness参考值为8-64v = step(_SpecularRamp, v); // 小于_SpecularRamp的值将为0，反之为1v = v * _SpecularStrength; // 定义高光强度，参考值为0.2color += color * v; // 在原有颜色的基础上叠加 这样的高光就更有手绘的感觉了，牛屎一块。但很显然对于头发而言光是一块牛屎高光是不够的，让美术自由的进行创作显然是更好的方案。于是引入了发光贴图（Emission），其本身很简单：就是在最后把发光贴图的内容显示出来即可。而之所以要单独划分贴图而不是画死在原贴图，在于要自由的控制透明度甚至曝光，以及让发光参与单独的光照运算（与高光类似的方法，摄像机视角与光照方向相加后与法线点积）。 到了目前仍缺一个日式2D卡通的一个特性：边缘光（Rim），一般为了表达物体处于光亮的环境下，属于光溢出的一种表达，有助于提升画面的层次感。实现原理也很简单：视角方向与法线点积，根据夹角系数取得当前视角下的模型边缘部分，为之加光即可。 12345678half VDotN = dot(viewDir, normal); // 视角方向与法线点积，获取夹角系数VDotN = 1 - saturate(VDotN); // 取反，方便计算half v = smoothstep(_RimRange[0], _RimRange[1], VDotN); // 与漫反射部分类似，做二值化，参考值为0.4-1v = step(0.5, v); // 小于0.5的部分都不要了v = v * _RimStrength; // 设定边缘光强度，参考值为0.1color += color * v; // 叠加 发光的构成大致如此，目前也许看起来不够明显，实是尚未调色所致，且看下文。 调色 先来看看目前的效果： 首先是整体颜色风格不符合主题，这个场景属于有着岩浆的密室，应该符合昏暗以及灼热的色调，使用Split Toning进行调色： 嗯，至少色调上像样了，但还是缺乏灼热的感觉，上Bloom看看： 哎呀，看着只是稍微亮了点的样子，那是因为Bloom需要配合HDR使用，将颜色突破0-1的限制下进行运算，才能做到光溢出的效果： 唔……这溢出的实在是有限，因为目前还处于Linear颜色空间，显示器对于颜色会进行处理，使得颜色之间的区间变小（明暗不明显），需要转成Gamma才能抵消之： 成了，如此便得出了昏暗且灼热的场景风格，高对比度（亮者更亮、暗者更暗）的画面。 后记 这算是本人进入图形渲染的一个里程碑，感觉这的确是个美术活。技术不过是让你能进入赛道罢了，真正决定效果的还得看美术的理念。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移植贪吃蛇——从C#到C++]]></title>
      <url>%2F2020%2F04%2F07%2Fsnake_cpp%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 因为某些机缘巧合，引起了我对C++的重视。一时兴起，决定将两年前用Unity写的Snake进行移植。经过两周的抽空，总算是完成了。项目采用现代C++标准编写，采用CMake构建，图形库为SDL。由于本次的重点不在于图形这块，所以没有使用原版的素材，采用矩形代替。 在工程实现上除了基本的业务外，还实现了C#的event以及的Unity的GameObject与Component。 本文将从C#开发者的角度出发比较C++的不同点，最后总结其思想。由于本人在此之前从未有C++的工程经验，对于许多特性在此之前也是一知半解，对于一些事物的理解若有误还请指教。 低成本封装 首先最引我瞩目的便是C++的参数传递，形如这般的函数：1void Init(const string&amp; title, int width, int height); 由于C++的引用参数string&amp;性质，将值传入时不会发生拷贝，而是等于直接使用原变量。可以有效降低封装抽象的成本，加上const字段是为使得形如&quot;123&quot;这样的常量区对象也能传入。 当然这在C#也并不是没有，ref便是如此。但这在C#并不会下意识去用，毕竟在C++若是不用指针或引用作为参数的话可是会直接拷贝新对象的，而在C#直接使用也不会造成很大的负担（值类型直接拷贝，引用类型用指针）。 其次便是C++的内联函数了，作为函数宏的替代品之一。可以在编译时将函数展开为具体的内容，节省了一次函数调用的消耗。但内联函数需写在头文件中，若是关联项多，修改后便会增加编译时长。且展开量过大也会增大代码量，增加编译时长。但不失为一个降低封装成本的手段。 明确的内存 其次与C#最大的不同便是对象的创建了，C++有着以下两种形式：12A a = A();A* a = new A(); 了解C++的自然晓得，前者在当前内存域下申请，后者在堆申请。而在C#则隐去了这个细节，而是设立固定的规则： 引用对象使用指针，原则上在堆申请，若对象的生命周期存在于申请的函数里，则在栈申请——是为逃逸分析。 值对象在当前内存域下申请，且由于不是指针，变量传递会产生拷贝。除非使用ref、in、out等参数关键字。 而C++的内存申请机制则带来了明确感，如在函数里申请生命周期只存在函数里的对象，需要明确的使用A a = A();方式。且在构建类的时候，对于那些不使用A* a = new A();创建方式的成员变量，其内存占用是明确的，在类对象申请内存的时候会一并申请，即这些成员变量在内存布局上可能是连续的。从这点来说可比C#要牛逼多了。 相似的容器 在容器方面，C++与C#大体看起来是相似的，当然在API的爽度而言还是C#更胜一筹（C++17拉近了不少）。但实际上还是存在一些细节上的不同，就比如我们常用的Key-Value容器：C++的std::map与C#的Dictionary在实现乃至功能上就不一样。实际上std::map对应C#的应该是SortedDictionary：它们都是基于红黑树实现，都是有序存储的表。而Dictionary则是基于哈希实现的，即我们俗称的哈希表，与之对应的是std::unordered_map。 通过命名能看出两种语言在这方面的倾向性：红黑树占用的内存更小，但查找和删除的时间复杂度都是O(logn)，而哈希查找和删除的时间复杂度都是O(1)。实际使用的时候感觉还是得权衡利弊，不能贪图方便就一直用一套。std::set与HashSet这边也是类似的对应，以此类推。 在序列容器方面的对应倒是工整：std::vector对应List，都是不断扩容的数组容器。链表方面则是std::list对应LinkedList。但std::array却无对应了，硬要说的话就是与C#的原生数组对应，毕竟这个容器出现的意义就是弥补与C语言兼容的原生数组。 顺带一提，在使用std::vector时由于会出现扩容复制的问题，需要考虑好成员对象的拷贝方案，乃至于内存泄漏的问题。 智能的指针 内存管理是所有编程语言都无法绕开的点，绝大多数编程语言对于堆内存的管理都是采用垃圾回收的方式。而在C++的鸿蒙时代则与C语言一样，需要手动管理指向堆内存的指针。尽管也有std::auto_ptr这样的东西，但在功能上还不够全面。而手动管理内存将难以解决对象在多处被引用时将如何安全销毁的问题，为了实现这种机制也得做出不少妥协。 所幸随着时代的发展，现代C++迎来了智能指针，它基于引用计数的规则，将裸指针包装起来，当符合销毁条件后便可自动回收。智能指针有着几种具体的类实现，而其中最常用的是std::share_ptr，当它持有指针时将增加计数，反之同理将减少计数，最终归0销毁。但其较之垃圾回收有个致命的缺陷：相互引用时将一直保持计数，无法销毁。为此C++引入了std::weak_ptr：它不会增加计数，在计数归0时持有指针也随之销毁。如此对于相互引用的情况下，分清主次，合理分配share_ptr与weak_ptr即可解决无法销毁的问题。 智能指针在使用上总有一种外挂的感觉，需要成体系的去使用。不如内置的垃圾回收式语言来的方便，且写起来还是有一定的心智负担（相互引用），不过在性能而言较之垃圾回收更为优越（回收对象与时机都很明确，且是被动进行的）。 模板与泛型 C++的模板与C#的泛型表面上用起来很是相似，实则有所不同。以下对比两者的差异：1template&lt;class T, int x&gt; // C++支持模板参数，可填写整型或指针 1GenericList&lt;T&gt; where T : Employee // 使用System.Object不支持的方法时，需进行类型约束指定基类 1234567// 这么骚的操作见过么？void f(int x);template &lt;class ... Args&gt;void Do(Args... args) &#123; f(args ...);&#125;; 从实际使用体验与两者的命名可以看出，「模板」的本质是参数化代码生成，而「泛型」则是类型参数化。即泛型只是模板功能的一部分而已。模板能实现的其他功能，在C#则以其他方式代替了（如变长参数params）。 后记 从以上种种便能看出C++与C#在设计哲学上的不同，C#通过约束开发者行为从而达到更稳定健壮的结果，哪怕会失去一定的性能与灵活性，而C++则更依赖开发者自身的素质（如C++支持多重继承而C#仅仅支持单类+多接口继承）。 从个人的使用体验来看，现代C++并非不能作为业务开发语言。只是对开发者的素质要求较之一般语言更高，从招聘成本与项目稳定性而言是个问题。如此来看，除非有必要的性能敏感且需要一定封装的核心层（如游戏引擎），否则用C + 脚本语言或者C#/Java这类可上可下的语言是个更好的选择。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Shader Graph踩坑实录]]></title>
      <url>%2F2020%2F03%2F08%2Fshader_graph%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 Demo也到了做渲染的时候了，经过一番鏖战后，算是大体完成了。但随着后续需求的到来，发现这套纯代码的Shader方案对于扩展、复用等方面有着诸多不便。于是便打起了Shader Graph的主意……经过一番纠缠，于是有了本篇踩坑实录。另附源码地址，但本篇并不会对其做讲解。基于Unity2020.1.0a20，渲染管线为URP7.18。 优劣 首先要明确的是：Shader Graph不支持Builtin渲染管线，且尚未处于彻底成熟的阶段，哪怕是最新版本尚有不少缺陷。但瑕不掩瑜，且说其优劣： 优点 由于节点化与Sub Graph的存在，Shader的组装将变得相当容易，极大提升了模块化水平。 调整Property与Keyword变得相当方便，纯代码下将需要多些工序。 内置各种节点，降低了美术参与创作的门槛。 能够实时预览每个节点造成的变化预览，虽然对我而言没啥用。 缺点 编辑器尚不够稳定，经常会出现整个程序崩溃的情况。 生成的代码不够优化，比较暴力，存在各种分支判断、重复函数（也许最终会优化？） 由于Slot机制的原因，可能会出现很多运算集中在片元着色器中。 对于创建Pass并不友好，需要修改源码。 来龙 其实一般的浅度Shader Graph使用者并不会如我这般踩这么多坑：直接使用内置的Graph模板进行创作即可。不幸的是，如前文所言：对于创建Pass并不友好，需要修改源码。于是便开始了踩坑之旅…… 在默认情况下，Unity的Package将保存在工程的Library/PackageCache目录下，这样子是不能直接修改源码的（Library目录下的东西属于可再生物，随时会被覆盖），需将之搬迁至工程的Packages目录下。 对于考虑到日后Shader Graph的版本升级情况，所以尽可能的不要修改原工程的内容，而是尽量新建文件。但考虑到Shader Graph源码下存在不少inner元素，直接在外面写自己的内容也并非彻底可行。只能直接在Shader Graph包下进行添加文件的方式了，这也是要将之移至Packages目录的原因。 我要做的事情相当明确：新建一个自定义的Graph类型。在URP下已经自带Unlit与PBR两种类型了，于是本人便基于Unlit Graph并结合先前实现的Shader的特性进行新类型的创作。 去脉 我们能接触到Unlit Graph创建的起点便是Project区下右键菜单的Create-&gt;Shader-&gt;Unlit Graph了，直接在Shader Graph源码包下全局搜索Create/Shader/Unlit Graph即可找到： 照葫芦画瓢在同目录下弄个新文件实现相同功能即可，这下我们便知道Unlit Graph的正主了：UnlitMasterNode。经过研究发现，它决定了在编辑器下Unlit Master Node的样式： 但这只是个壳子罢了，根据代码中的IUnlitSubShader为引，找到了其核心： 这个UniversalUnlitSubShader的作用相当简单：根据编辑器的设置生成Shader代码。如上图便可看出定义Pass数据结构的行为，这也是诱使我来改源码的直接原因。在里面你将见到形如这般的代码： 123456789101112131415161718var unlitMasterNode = masterNode as UnlitMasterNode;var subShader = new ShaderGenerator();subShader.AddShaderChunk("SubShader", true);subShader.AddShaderChunk("&#123;", true);subShader.Indent();&#123; var surfaceTags = ShaderGenerator.BuildMaterialTags(unlitMasterNode.surfaceType); var tagsBuilder = new ShaderStringBuilder(0); surfaceTags.GetTags(tagsBuilder, "UniversalPipeline"); subShader.AddShaderChunk(tagsBuilder.ToString()); GenerateShaderPass(unlitMasterNode, m_UnlitPass, mode, subShader, sourceAssetDependencyPaths); GenerateShaderPass(unlitMasterNode, m_ShadowCasterPass, mode, subShader, sourceAssetDependencyPaths); GenerateShaderPass(unlitMasterNode, m_DepthOnlyPass, mode, subShader, sourceAssetDependencyPaths); &#125;subShader.Deindent();subShader.AddShaderChunk("&#125;", true); 如此情况便变得相当清晰了，只要清楚你想生成怎样的Shader代码，在摸熟了生成代码的API，便可自由地进行创作了。通过右键节点可以随时查看生成的代码情况： 注意事项 也许看似还算简单，但其中坑点还是有不少的： 不要尝试采用继承的形式去新建新类型，其本身代码就没打算让你这么做，必然会碰壁，除非改源码（如此便违反原则了） 做出了修改后，要到对应的Graph文件进行Save操作触发检测。 也许是检测的原因，有时候HLSL代码做出了修改后不会被识别到，需要换下行。 Shader Graph生成的着色器参数有着自己的一套处理方式，务必参考自带的代码。 Unlit Graph的主Pass并没有LightMode，想做背面Pass的时候要注意下。 Unlit Graph将渲染模式、混合模式、剔除做成节点设置并不是一个好选择（无法让材质修改），推荐按照URP的方式做成材质属性。 Shader Graph对于生成的Shader代码存在分支数限制，需要到Preference-&gt;Shader Graph进行修改上限。值得一提的是，全局Keyword与局部Keyword似乎是分别对待的。 Shader Graph并不存在完整的环境，它是无法识别到一些渲染管线里的函数的。所以在编写Custom Shader的时候需要加上#if SHADERGRAPH_PREVIEW分支判定以处理在编辑模式下的情况： 123456789101112131415161718192021void MainLight_float(float3 WorldPos, out float3 Direction, out float3 Color, out float DistanceAtten, out float ShadowAtten)&#123;#if SHADERGRAPH_PREVIEW Direction = float3(0.5, 0.5, 0); Color = 1; DistanceAtten = 1; ShadowAtten = 1;#else#if SHADOWS_SCREEN float4 clipPos = TransformWorldToHClip(WorldPos); float4 shadowCoord = ComputeScreenPos(clipPos);#else float4 shadowCoord = TransformWorldToShadowCoord(WorldPos);#endif Light mainLight = GetMainLight(shadowCoord); Direction = mainLight.direction; Color = mainLight.color; DistanceAtten = mainLight.distanceAttenuation; ShadowAtten = mainLight.shadowAttenuation;#endif&#125; 后记 现在感觉游戏开发的未来方向就是连连看了，从这点来说UE4的确算是时代前沿。在编辑器里加入逻辑控制元素，让更多人能加入创作，尽可能地解放生产力，的确是游戏开发所需要的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Unity骨骼动画的总结]]></title>
      <url>%2F2020%2F02%2F01%2Fanimation_guide%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 恰逢假期，在家继续推进Demo，骨骼动画相关的调研算是告一段落了，遂以本文记录相关要点。 首先要明确一点，本文所说的骨骼动画皆是3D模型的骨骼动画，与2D精灵的骨骼动画无关，虽然原理大致相通。 网格、骨骼、绑定 了解过3D相关知识的都知道，模型(Model)是由一个个三角形组成的，而这种三角形的学名则是网格(Mesh)。当然在DCC软件里为了方便创作，会用2个三角形组成四边形作为网格： 然后便是骨骼(Skeleton)了，它是驱动模型运动的根本，如下图所示，这是一种彼此之间有父子关系连接在一起的长条状玩意： 最后便是让模型跟着骨骼一起运动了，这个骨肉融合的过程称为绑定，具体要做的事便是将某节骨骼与相关的网格建立关系： 如上图所示，模型上有着不同的颜色，这表示该节骨骼所影响到的网格权重值（蓝色为0，红色为1），所以绑定也俗称“刷权重”。权重值越高，该节骨骼对相应网格的影响便越大（存在多节骨骼对相同网格存在影响，此时便要通过权重值来决定优先级了）。 随着时代的发展，现代DCC软件基本配备自动刷权重的功能了。做好模型部件的划分（每个部件拥有独立的骨骼，通过各骨骼之间建立关系来联系模型），减少每个模型的权重复杂度，如此通过自动刷权重基本可以应对一般情况了。 模型与动画 生成给Unity使用的模型与动画我选择FBX格式，毕竟这算是最流行的3D格式了。对于动画，我选择一个动画一个FBX文件的形式（业界也有全部做到一个文件里，在Unity内分割的行为），动画FBX文件里只有骨骼与动画信息，不含模型。 说到这里，便有一个绕不开的点：多个模型复用相同的动画，这里涉及到Unity里的两种骨骼动画模式：Generic与Humanoid。 Generic如其名般：一般的动画，在这种动画模式下实现复用的思想很朴素：只要模型的骨骼与动画的骨骼要素相同，那么复用便是水到渠成的事了。这也表示必须同类模型与动画的骨骼结构是一致的。这也表示难以使用外界的第三方资源，对于一些以拼凑、同人、大乱斗为特色的民间项目，或是想直接使用某游戏提取出来的动画，那便捉急了。 Humanoid则不然，这是一种专为人形设计的动画模式。如下图所示，它定义了人体通用的若干个关节点，将模型对应的骨骼填进去即可： 事实上Humanoid便是做了一层中间层转换，让各自的人形模型的骨骼信息统一抽象为上图这套体系，并且还做了关节运动幅度的可控，如此便可实现复用了。且Unity实现了自动识别填充，使用起来还算方便。 但事实上我放弃了这种做法，选择了Generic模式。原因如下： Humanoid模式为了兼容不同体型下的情况，禁用了具有缩放行为的骨骼动画。 Humanoid模式只是为人形考虑，但实际上需要动画复用不只是人形。 由于Demo模型选用的是小泥人，并没多少合适的第三方动画选择（已尝试过）。 哪怕是人形，事实上也会有一些Humanoid无法顾及到的部件（如头发）。 既然不用第三方动画，那么骨骼结构的稳定性自然有保证。 以上原因不是说用Humanoid模式就完全无法解决，But simple is good，Generic就完事了。 Animator: 切换、分层、混合树 时值2020年，Animator自然是动画组件的不二之选了。如下图所示般，构建动画状态机，实现一个有机的动画播放环境： 首先要注意的是，不推荐将动画状态机当成单位业务的状态机使用，虽然动画状态机有提供挂载脚本的形式，但事实上单位的状态并不是与某个动画绑死的，应该由状态去播放动画，而非是动画下绑定专门的业务。让动画的归动画，状态的归状态吧！ 在动画切换控制方面，我使用了Animator自带的变量机制(Parameters)，结合条件切换、动画状态脚本、代码控制等方式，实现动画的高可控切换。 如前文提到的动画复用问题，实际上哪怕骨骼主体相同，但仍会有各自的特殊部件，这时候便要用上Animator的分层机制(Layers)了。通过定义多个不同的层次，在层次中使用Avatar Mask确定影响的骨骼部位，在层次中定义各个动画状态下对应的部件动画。可以为层次定义独立的动画状态机体系，也可以在设置中选中Sync启用以主体层为准的体系。个人更推荐后者，除非与本体动画无关。 最后是业界不少人士喜欢用的混合树(Blend Trees)，分为多种类型（不同的维度乃至于机制），原理为定义若干个动画，确定每个动画在变量组合的特定值下权重最大（播放优先级最高），如此通过操纵变量即可灵活混合相关动画（每个动画的元素都有一定的权重，最终混合成独特的动画）。本人暂时还没用到，主要是追求更明确的动画，而非那种融合的感觉。 补间与帧动画 骨骼动画的本质，便是在不同的时间点为某节骨骼定义了特定的位置、缩放、旋转。动画的运作便是根据两个时间点之间的骨骼数据做数值变化，这种行为称之为补间(Tweens)，同理骨骼动画也就是一种补间动画。与补间动画相对应的概念是帧动画，帧动画只会在特定的时间点发生变化，时间点之间的运动途中是不变的，在许多经典的2D游戏动画便是这种做法。 为何我会提及到这点呢？一个很明显的区别：较之帧动画，补间动画显得实在是太流畅了，毕竟理论上游戏运作的每一帧它都在改变。但是流畅不是很好么？这一直是电子游戏的追求才对啊！在大多数情况下也许没错，但有时太过流畅，反而会失去「力量感」，说的再通俗点，就是没2D游戏内味了。我想这也是不少一般3D动作游戏做的不好的一点。 这种现象在日本动画业界运用3D时早有发现：由于2D手绘帧的标准是24帧每秒，而如果3D动画按照视频播放帧进行输出，就会显得两者仿佛根本不在一个世界般。故后来都选择了按照2D手绘帧的帧率进行抽帧，以此达到同步。当然哪怕如此，3D动画也是无法还原出2D手绘帧那股味的，一者在于手绘帧的每帧内容都是人为创作的，具有独特的节奏感。另者在于2D手绘帧的运动帧为了表达动感，往往会画成糊成一团的样子： 这种效果在3D动画基本上是难以实现的，所以往往会盖一层特效解决： 当然《塞尔达传说：荒野之息》对此的处理已经算是上乘了，特意选择了与武器本体颜色相近的特效，在形状上也与2D运动帧接近。个人认为可以在此基础上为武器加入短时间内夸张的形变，使之更有张力。这在《守望先锋》里也有相关运用，留待后日实践验证了。 言归正传，鉴于补间动画过于流畅的特性，为此我也类似日本动画业界的做法一般，按照24帧每秒的形式对动画播放进行了抽帧。实现思想也很简单：平时将Animator暂停，使用一个定时器，在特定时间点让Animator一次性把暂停的时间差更新补上。如下图对照所示（图1抽帧，图2没有）： 当然这种方式并不完美：真正的2D帧动画每一帧的持续时间都是人为确定的，而这样只是粗暴的抽帧罢了。当然人为确定帧时间的方式势必带来更高的人力成本，具体如何仍需取舍。 后记 关于「补间与帧动画」一节纯属个人看法，在正统3D派看来也许属于邪道也说不定（笑。骨骼动画涉及的相关种种实际远不止如此，如换装、部位组合动画等，限于篇幅，就不展开了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Unity光照模式的总结]]></title>
      <url>%2F2020%2F01%2F12%2Flight_guide%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 近日在琢磨Demo应该选择怎样的光照模式，遂做了个试验：对比在同一场合下，各种模式的情况。故以此文记录之（版本为2019.2、平台为Standalone、渲染管线为Builtin）。 环境光 环境光(Ambient)严格来说并不是一种光照，它只是单纯的为所有显示元素上色罢了。可以理解为2D游戏便是有个(255, 255, 255)环境光。可于(Window → Rendering → Lighting Settings)下的Environment Lighting进行设置。 环境光是无论如何都需要的，一般用于决定画面的底色。下图便是用了白色的效果： 看到上图便能理解我说的「环境光严格来说并不是一种光照」，毕竟连影子都没有，整个画面显得很单薄。但事实上在早期、以及现在一些不依赖光影的游戏是有这种做法的。它们一般会采用类似2D游戏的做法，在素材层面解决各种显示效果问题。对于不依赖光影、强调美术的绝对控制的游戏，使用纯环境光是个方案。 顺带一提，在Environment Lighting设置下的Gradient与Skybox模式有着不一样的效果，属于更高级的环境光实现。 实时光 实时光(Realtime)顾名思义，就是每时每刻都在进行的光照。在Light组件的Mode属性设置为Realtime即是。实时光的优缺点很明显，如下： 优点 游戏时可随时改变光照的状态，即刻产生反应 随取随用，无需烘焙 光照效果最好 缺点 在正向渲染(Forward Rendering)下，画面同时出现多个光照时，开销较大 为了节能，某些设备、设置下，光照的数量有限 实时光一般就是开箱即用到的光照，效果如下： 可以看得出，各项消耗指标都比纯环境光要高，而该场景只有三项光照（平行光1个、聚光灯2个）。故一般游戏都不会如此奢侈，会采用各种手段来达到相同的效果。 而以上却还不是效果的极致，还差个全局光照(Global Illumination)呢。刚才所见的光照只是「直接的光照」罢了，它只会考虑到照到了谁便处理谁，没有从全局的角度去考虑。在开启全局光照后，除了直接光照之外，还会产生物件之间相互反射的间接光照。效果如下： 从画面效果来看变得更为深邃了，墙壁与地板都有了反射后的光渍，而各项指标实际上与局部并无不同（疑似）。使用它的前提是要在上文的Lighting Settings下开启Realtime Global Illumination，并且为静态物件做好Static标记。具体实现细节请自行查阅官方文档，在此不表。 当然，这并不代表全局光照优于局部光照，就比如有些游戏的画面风格并不喜欢那些全局光照带来的光渍。还是要看想要怎样的美术效果。 烘焙光 烘焙光(Baked)可谓实时光的反面：根据光照信息预先渲染成贴图，最后盖到场景上。这个「根据光照信息预先渲染成贴图」的过程，是为烘焙。而烘焙的类型、算法、设置有着多样化的选择，直接影响烘焙的时长、效果、贴图大小与数量。也因烘焙的特性，只适用于静态物件（标记为Static的对象）。优缺点如下： 优点 部分渲染元素（取决于烘焙类型）没有实时运行的开销 属于全局光照，拥有间接光 缺点 光照属性不能运行时修改 动态物件不受影响 烘焙耗时 烘焙类型主要分三种，效果如下：Subtractive: 全烘焙Shadowmask: 烘焙阴影与间接光Backed Indirect: 只烘焙间接光 可以看到效果是一个比一个好，但性能却是一个比一个耗。并且可以看出，由于烘焙设置的问题，效果是不如实时光的。而通过设置达到最优的话，烘焙时长则又是个问题了，鱼和熊掌不可兼得啊（砸钱便能我全都要）。 对于Subtractive，只需把Light组件的Mode属性设置为Baked即可。对于其余两种，实际上是一种实时光+烘焙光的混合方案，则需设置为Mixed。由于动态对象不受烘焙光影响的特性，Subtractive下的胶囊仔直接跟纯环境光时一个样了。解决方案有很多种，如采用Mixed方案（静态物件烘焙光、动态物件实时光）、Light Probes等。 顺带一提，关于Shadowmask，在阴影设置中可调为Distance Shadowmask。如此将取决于阴影距离的设置，在阴影距离内的阴影，将采用实时阴影，距离之外的则是烘焙阴影。也算是一种提升品质的方式吧。 烘焙光在业界的应用相当广泛，其中Subtractive式烘焙在早期游戏与现代手游可谓家常便饭，妥善使用Light Probes也能达到不俗的效果。 后记 以上只是本人粗略的实验与记录，实际上光照的内容浩如烟海，远非本篇所能涵盖。在光照方面本人也只能算是初学者，有所不对还请海涵，并欢迎指教。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2019年度总结]]></title>
      <url>%2F2019%2F12%2F31%2Fsummary_2019%2F</url>
      <content type="text"><![CDATA[与前两年不同，今年可没有“不知不觉中，一年又过去了”的感觉。也许是上班了之后，对日子有了概念吧（毕竟元旦放假，笑）。同时与前两年相同，特作总结，以为归纳。 今年的Blog内容只有寥寥6篇，且全是DFQ相关。盖因10月之前都在紧张的开发中，实是无暇整点别的，希望明年有所不同吧。 若论今年最大的成就，自然是DFQ的完成了。相关事宜也在后记有所总结。算是这些年来DNF同人的一张答卷吧。 除此之外，自然是利用这些年的积累，成功的找到了一份符合预期的工作。虽称不上惊艳，但也不差。在找工作期间也受到了不少业界同仁朋友的帮助，在此感谢。工作之后的最大好处便是生活作息规律了不少，至少不存在通宵了。其次是袋里也算有俩破钱，吃点买点都还凑合。在工作上也见识到不少业界才有的东西，并且深刻感受到了屎山、祖传代码、各种对接联调需求扯皮的滋味。也逐渐理解业界不少游戏明明肉眼可见的可调优项，却事实上没去改的现实。 主要原因在于，团队人数越多，意志的贯彻性就会越差。并且由于人多，野心也就愈大，需要做的杂七杂八也就愈多，不类独立游戏会专注于某项去做好。并且由于团队传承的关系，不免会存在换皮、祖传、屎山代码的现象。亦有可能熟悉这套玩意的核心成员已经不在而导致整体水平下滑，且由于规划、时间问题，没有成本去重构、推翻重做，这也是很无奈的事实。故工作后我最大的两点感受是： 自己能白手写出某套东西并不算什么，能基于别人的东西去改出来那才是本事。 团队人愈多，工作流程（工具链、生产线、规章制度）就愈重要，这决定了团队生产力释放的多寡。并且人类之间的信息交接力其实很差，人多就不免要付出对接成本，这也是要通过工作流程去尽量减少的成本之一。 说完工作的事，介于「生命不息，整活不止」的原则，新的整活计划自然如火如荼的进行中。如去年所言，需要在3D游戏开发方面发力。结果今年都在忙DFQ，有点惭愧。以上便是本人的2019年度总结，且待明年的Blog吧。 无双草泥马 2019.12.31]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《DFQ》开发随录——后记]]></title>
      <url>%2F2019%2F10%2F17%2Fdfq_end%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 DFQ终究是顺利的开发完成，并在发布之后的短短四日内达到接近十万的下载量。赢得广大玩家的好评，甚者认为比之官方的手游品质更佳。然而这一切恍若黄粱一梦，于昨日晚上收到了来自腾讯的律师函，要求删除相关下载渠道与宣传内容。 取得这等成绩自是喜人，能被腾讯警惕也证明品质确实出色。只可惜游戏尚有一些待完善之处，无法再为玩家提供更新了。在此期间也有不少请求换皮合作的邀请，但本人志不在此。也不想讨论相关太多，就来为这个项目做个总结吧。 程序 关于制作DFQ的想法，在《阿拉德英雄传》3.0搁置以后便有了模糊的想法。认为要做一款简洁爽快的中小型DNF同人手游，作为我、以及开元的DNF同人最终章。但随着增长了见识以后，便发现自己的程序架构掌控力不足，于是花了不少时间恶补。且前期对于要做一款怎样的游戏并无清晰的概念，遂直到2018年6月才正式开始制作。 由于DFQ算是弥补3.0搁置的一个执念，于是依旧选择了LÖVE引擎。事实上这是个重大的决策失误。LÖVE关于移动端方面的功能只是刚刚推出，且是冷门引擎，没人帮忙踩坑。于是在制作时便遇到了很多问题，包括相关库的缺少或不合适以至于要造轮子、引擎本身的BUG之类等等。在发布之后更是遇到了诸多问题（NO GAME、全面屏、DPI等），在此奉劝各位，不要用冷门引擎。 说回程序本身，这次基本上是达到我的要求了，至少工程不再是一塌糊涂、难以协作的状态了。对于各种方面的写法问题也有过深刻的研究（如活动对象采用ECS架构），对于代码格式与写法也有了规范。不足之处在于状态的业务按理来说应该配置化，而非OOP，因其存在大量相似而不同的业务，而这些部分是难以用OOP解决的。以及在OOP的规范上，我引入了private（以_前缀表示），然而会发现很多时候这只会增加不必要的思考负担以及封装成本，这方面该如何处理其实至今我仍未有答案（在业界也是众说纷纭）。 为了弥补Lua没有强类型与智能提示的缺点，我引入了EmmyLua。所以看过之前的开源工程的会发现代码会有形如---@class XXX的注释，不过这种外挂的形式终究不如原生来的爽快，且缺乏运行前检查的功能。对于代码健壮性的建设尚嫌不足，由此可见TypeScript才是究极的工程化脚本啊。 在后续测试的图中遇到过一次严重的内存泄漏事故，基本上刷到第三个地下城时便会内存膨胀到难以接受的地步。通过使用LuaMemorySnapshotDump发现，由于我为了减少内存申请，会将一些固定的table类参数写成模块变量，而使用后却没有及时清空，导致游戏对象一直依附其中，无法回收。以及为了优化而做的对象池也是如此，真是汗颜。 美术 美术方面可以说的不多，首先是由于因需求做了个粒子编辑器，导致对粒子效果的掌控力上升。游戏的粒子特效使用率较之《阿拉德英雄传》有了大幅的提升。 在人物素材方面，实现了非常强大的纸娃娃，并且为了效率优化，纸娃娃是拼合成一张大图的，缺点在于合成相当耗时，需要在恰当的时机进行（如读图）。并且部分设备支持的图片大小最高为4096，而实际上则出现了超过该大小的图片（此问题至今尚未修复）。 在优化方面，由于引入了图集与压缩的措施，游戏的加载速度与显存占用是得到了极大的提升。在尚未采取压缩之前，小米9会出现显存带宽爆炸的情况。可以说安卓设备五花八门，令人十分头大。 UI方面，立绘依旧是小山龙同志的作品，质量较之当年可谓进步明显，原本打算采取live2d的方案，却因工期延宕而搁置了，实是一憾。至于界面本身，可以看出对于手游而言，连及格都称得上是勉强，实是因为一版过兼无经验所致。 手游UI与端游UI的不同处在于，由于屏幕太小，实际上UI要做的很大才显得正常。并且由于有着触控的需求，按钮也必须大且位置合适。如果为了美术效果而做得小，那也得必须要求附近无其他冲突项，且实际可触控范围要比素材看起来大才行。 游戏性 DFQ的原初想法实是一款刷刷刷的类暗黑游戏，但本人感觉这年头的游戏都过度强调养成了。遂在砍掉养成的前提下重新审视，定下了三国战纪+Roguelike的主基调。三国战纪的元素在于：角色扮演、街机闯关、拾取道具，Roguelike则是随机性了，可谓独立游戏时下的流行元素，当然大家不约而同选择Roguelike的原因很简单：游戏内容不足，所以要用随机性来增添耐玩性。这么一组合起来，DFQ的样子便很明显了：开局一把刀，一切全靠打，随机地图事件，横版街机闯关。 但是仅仅如此还是不够的，要是玩家一直用着一成不变的搭配进行游戏，那可就太浪费了。传统游戏对于此的解决方案有：上下级替换、针对性关卡替换，然DFQ没有条件搞上下级替换，针对性替换也未免苛刻。于是抄袭《塞尔达传说：荒野之息》的武器耐久度设定，让武器、道具、技能都具有轮替性。这份轮替性对于玩家而言实是辛辣了，以至于赢得不少吐槽。在后续版本中便为此做出了调整优化，但实是最佳之法。关键在于：玩家需要自己感到可控的设计，而非稀里糊涂的机制。DFQ在不少方面都有类似问题（如最初设想的动态难度），实该检讨。 在关卡设计上，DFQ是以传统游戏的标准进行设计的，做出了不少较之DNF的突破（如跨房间追击战、迷宫等）。在开发前期犯下一个严重的错误：以端游的标准去做手游，以至于难度过大。手游的操作成本比端游要大，以及更适合轻度的体验。传统的DNF操作方式并不够爽快，遂在此基础上加入了小技能可互相强制、普攻可减少技能冷却的设计，让整个游戏的体验如打了肾上腺素一般。 除此之外，在做《阿拉德英雄传》多年以来，落下不少错误的思想，如怪物的攻击频率相当鬼畜、没有合适的前后摇等。虽然较之当年，我的ACT设计理解有所提升，引入了反击元素，但仍是不足。在小草泥马的一番军训后，引入了紧张时间与舒适时间的概念，领悟了张弛有度的道理。怪物的设计上会做出提供玩家利用的破绽，让战斗的体验达到了业界平均水平（指国际）。 宣传 在此感谢轻声低语、瓦伦、夕阳飘羽三位同仁的协助，在DNF百度贴吧、COLG等处得到了极大的曝光，也感谢纷纷去安利、自发宣传的玩家们，以此得到了广泛关注。取得了下载量近十万、B站宣传片十三万播放、贴吧关注量近七千、群人数两千七、COLG帖子47页的成绩。 另外意想不到的是，以前《阿拉德英雄传》的玩家群体的活跃度也很高，并且开元工作室的名声也比想象中要大（不少人都知道，包括DNF吧的吧务），可见以前做下的成果也是有回报的。 其实在我看来，比较核心向的游戏，只要你知道受众的聚集地，并且有相关号召力的人士愿意帮忙。在赢得了核心玩家的认可下，宣传效果是非常棒的，哪怕远在韩国的好船同志也收到消息并通关了。这点和业界从广泛人群中捞玩家的买量游戏还是有所不同的。 后记 其实DFQ的成功，除了本身品质的优秀之外，更在于官方手游迟迟未发，当然最近又有动作了，这也算是撞枪口上了吧。且DFQ属于手游里少有的偏传统的单机类型，在玩腻了抽卡养成流水关卡的玩家看来，自然是十分闪耀的。而我之所以拒绝那些合作换皮的邀请，也在于我并没有想过符合游戏的商业化改造方案，如果按照市面上的那一套进行，结合下一次的天时地利人和，感觉迎来的只会是暴死吧。 经过这次的验证，可以见到我的ACT理解程度已经进入了新的台阶，然而这还不是我所能做到的极限，若有机会一定会再次整活。当然同人游戏是不会再做了，这次已经是撞倒了天花板，在各方面有其局限性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《DFQ》开发随录——AI]]></title>
      <url>%2F2019%2F05%2F31%2Fdfq_ai%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 DFQ是PVE（Player VS Environment）游戏，那么自然要有AI了。DFQ的AI实现并不算复杂，并没有用到时下流行的行为树（Behavior Tree）。原因在于不需要做到太精细的操作，且AI部分的业务不需要执行策划参与（不需要编辑器化）。本文将一一叙述其中要点，相信对于同类型的游戏也有一定的参考价值。 宗旨 AI设计的宗旨只有一个：根据游戏的各种情况，决定进行怎样的操作。这样的思路其实挺仿生的，我们玩游戏的时候本质上也是如此。要注意的是，玩家进行操作的方式是通过外设（键盘鼠标手柄触控等）输入操作信息（按键坐标等）。从这点来说，AI也可以这么做，以进行虚拟的输入操作。这么做的好处是很明显的，如此AI与玩家在功能上达到了一致，AI也不需要与某个具体的功能耦合，只需要关注相应的操作指令，无需关注具体的功能实现。 而这一切只需要做一套操作模块即可，并且做联机时来自其他玩家的输入亦可如此处理，通过这种方式达到了玩家、AI、联机三者的有机统一。可谓「软件开发中遇到的所有问题，都可以通过增加一层抽象而得以解决」的一次实践。 当然这也会引入新的问题：某些功能只想AI拥有，那该怎么办？DFQ中的非转向移动便属于这类，解决方法很简单：设计一个玩家无法触发的操作指令即可。 对象 AI的实体存在就是个类对象（下文称AI对象）而已，它会被外部调用的基础函数只有两个：Update和Tick。Update用于处理持续性的业务，而Tick则是一次性的业务，当然两者可能会有所结合（Tick接收参数，以驱动Update的运作）。 AI对象主要会存在的场合有：常驻（移动和攻击）、技能（判断是否应发动）、状态（某些状态下需要后续的操作），通过配置化的方式，即可灵活的组合需要的AI了：1234567891011121314return &#123; script = "base", state = "attack", ai = &#123; script = "battleJudge", collider = "duelist/goblin/skin/3-attack" &#125;, attackValues = &#123; &#123; damageRate = 1, isPhysical = true &#125; &#125;&#125; 如上配置所示，这是个技能的配置。在AI部分选择了battleJudge类，并提供了用于判断范围的collider参数。如此便定下了该技能的AI方针：使用collider判断是否存在敌人，存在则按下技能对应的按键，以发动技能。 实现 说完基本构成后，再来说说一些具体AI业务的实现吧。 移动：移动AI的核心构成有三 获取目标：遍历符合条件的对象，涉及到阵营等因素。 寻路：以目标为终点展开的寻路，由于DFQ使用的是网格地图，所以使用A星之类的寻路算法即可。 输入操作：获取到移动路径后，通过发出输入指令以驱动角色以之移动。要注意的是，这种方式不可能做到完全贴合路径，所以出现了超过了路径点的情况也不会作处理。 攻击：攻击AI要做的事情很单纯，遍历技能以Tick它们的AI对象进行发动而已。要注意的是，技能的使用顺序要建立优先级进行排序。 判定：这个判定，便是上文的battleJudge了，通过collider以判断目标是否存在。这里的collider便是先前打击感所言的立体矩形，如下图所示： 以上便是DFQ里值得一提的AI业务。顺带一提的是，AI是典型的不需要立即生效的业务，所以可以考虑每帧只执行一个单位的AI业务，以此减缓性能压力，并且避免敌人一窝蜂展开攻击的现象。 后记 在本文开篇时，输入AI二字的我其实有点恍惚。短短数年，AI几乎成了深度学习/机器学习的代名词了。在游戏领域一个理所当然的缩写反倒让我踌躇了一瞬，真是唏嘘啊。也许以后的游戏AI真的都成了基于强化学习的实现也说不定呢（笑。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《DFQ》开发随录——打击感]]></title>
      <url>%2F2019%2F04%2F30%2Fdfq_hit%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 对于动作游戏（本文所谓的动作游戏具体指由FTG衍生而来的「超人系ACT」，如鬼泣、猎天使魔女等）而言，打击感自然是重中之重，本篇就来讲讲DFQ的打击感实现思路吧。 首先要明确打击感的定义，本人将之定义为：攻击命中时产生的反馈。就这点而言，打击感并非是动作游戏的专属，凡是涉及到攻击交互的游戏都有。而动作游戏与之不同在于会对在攻击中附加控制效果（击退、击飞等），使得动作游戏成为了围绕打击感展开操作的游戏。 而DFQ的打击感基本源于DNF，在此基础上加入个人的理解，接下来便一一讲解其中构成。 判定 在产生攻击命中之前，自然得讨论如何触发了。众所周知，动作游戏讲究「所见即所得」——必须是看上去击中了，才算是命中。所以自然要使用一些方式去近似地模拟素材的边界范围，以此进行碰撞判定。而DFQ的做法则相当粗暴——直接构建一些近似的矩形，当然这矩形却不一般： 如图所示，人物拥有两种颜色的矩形，其中白色矩形表示人物的X-Z轴矩形，红色矩形表示为X-Y轴矩形。与一般的无纵深横版游戏（冒险岛、胧村正等）不同，DFQ这类可进行上下移动且滞空的横版游戏（DNF、三国战纪等）会去构造一种「逻辑上的三维空间」： 当然实际上可以直接使用3D矩形（立方体）进行构造，只是2D图形下不便表示，于是分解为两个矩形进行。自然地，判定时也是红对红、白对白。至于判定算法，由于DFQ没有太精细的需求，矩形不会参与旋转变换，故直接使用AABB即可。 击退 话不多说，直接上图： 击退是打击感中最基本的元素了，当然将之命名为击退只是个人行为，在业界它有着各种各样的称呼，如stun、硬直、僵直、気絶等，在此一提。 由图可见击退有两种不同的姿势（为了表现的丰富度），敌人会保持被击姿势一段时间，且变速位移一段距离。以函数的形式表示便是stun(time, speed, acceleration)，time表示保持姿势的时间，speed为位移的初始速度，acceleration为速度的衰减值（也可以是加速值），通过acceleration来每帧减少speed，以此实现简单的变速运动效果。当然speed与acceleration并非是必须的（不带位移的击退），但time则必须有（无time不stun）。 击飞 同样，直接上图： 与击退同样，击飞也属于动作游戏里最核心的控制效果之一，它的别名也很多，如flight、击倒、倒地、浮空等。 击飞这种控制效果在最初只是作为一种动画表现手法而已，一般用于敌人死亡、某些想表达击飞的招式等。敌人处于击飞动画时一般无法或难以继续进行互动。将之发展的据说是CAPCOM开发《鬼武者》时触发的一个BUG——敌人处于击飞时被后续攻击而产生了滞空效应。从此一发不可收拾，铸就日后《鬼泣》皇牌空战之名。 而DFQ身为2019年的游戏，自然不可能落后： 以上两张图基本可以窥得击飞之全貌了： 击飞在状态上可分为上升、下落、倒地，上升与下落都会进行类似击退的变速运动，且根据进度改变姿势。 姿势内容为击退的两个为基础外加它们的90度旋转版本及倒地。 在击飞时被攻击会切换姿势且保持滞空一小会，形成了浮空连击的效果。 除此以外便是X轴的位移效果了，这点与击退一致。 倒地会根据浮空高度结算出「再击飞」，画面表现上为落地弹起，若高度不足则直接倒地。 与击退类似，击飞的基本函数形式则是flight(speed_z, speed_x, acceleration_z_up, acceleration_z_down, acceleration_x)，参数含义与击退类似，不再阐述。一般而言acceleration_z_up与acceleration_z_down会选择默认值，speed_x与acceleration_x则为可选项，但speed_z必须有（无speed_z不flight）。 特效 继续上图： 特效其实没什么好说的，如果说动作姿势是描线，那么特效便是上色了。需要注意的是特效出现的位置一般得是矩形碰撞的交点处，这样才有「打中这个位置」的感觉。 特效的种类一般就是斩、打、突、气四类（利器、钝器、锐器、魔法），外加出血之类等等，多多益善。 顺带一提的是，由于特效算是一种创建销毁十分频繁的对象，值得为之做对象池以减少创建销毁的开销。 声音 这下上不了图了，毕竟声音的可视化形式一般人类都看不懂（笑。 由于打击感是攻击命中时产生的反馈，而反馈的形式自然不局限于视觉上的，听觉也相当的重要。当然这里讨论的声音可不仅仅是攻击瞬间产生的部分，还包括了整个招式过程。 一般而言，一个招式基本会包含以下元素： voice：如人物发招时的叫声，播放时机不限。 swing：如人物挥剑的声音、特效产生的声音，一般于运动帧时播放。 hitting：如刀砍到身上的声音，于命中时播放。 damage：敌人被攻击的惨叫声，于命中时播放。 声音这部分在业界不少垃圾游戏可谓是偷工减料的重灾区，实际上万万不可忽视，毕竟有时候效果好不好就靠听个响（代表：拳皇）。 Hitstop、闪烁、抖动 这仨放一块讨论是因为他们相辅相成： Hitstop这玩意我对其没有准确的中文词汇，业界一般称为硬直、僵直、卡肉等（可见多容易与击退混淆）。其定义如其名般：因hit而导致stop。表现形式为人物停止运动一段时间，这里的运动包括位移、动画之类。Hitstop是敌我双方皆有的，我称本体的Hitstop为Selfstop，敌方为Hitstop。由此可见，卡肉这个说法其实很恰当，感受起来就像是一下刀卡到肉里了。一般Hitstop的高低可以用于表示攻击的轻重，以及像内功拳法、一闪刀法等延迟杀伤效果也可以通过高Hitstop达成。 至于闪烁就更直白了，就是敌人表面有一层纯色遮罩渐变消失。值得注意的是，闪烁的运作也会受Hitstop影响，故在Hitstop期间闪烁是保持初始状态的，看起来敌人就是蒙上了一层白色。这么做可以使得命中的效果更为明显，在业界中《王者荣耀》也采用了这样的表现手法。 抖动在图中也许看不太出来，主要就是设定个时间值以及抖动范围（xa, xb, ya, yb），人物在时间内就会随机位移，形成抖动的效果。与闪烁同样，在Hitstop时间是不会流动的，所以抖动与闪烁类似，基本上便是用于加强Hitstop的表现力。在业界中CAPCOM的《吞食天地》也采用了这样的表现手法。 后记 以上只是打击感的一些机械的构成，实际上要做好打击感得充分利用许多元素，如场景震动、运镜、符合节奏的连击等。实际上它是一门导演的学问，要想培养就只能多抄多想多做。限于素材与平台，未能表现更丰富的元素，只能有待日后进军3D再说了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《DFQ》开发随录——随机掉落]]></title>
      <url>%2F2019%2F03%2F31%2Fdfq_drop%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 随机掉落可谓时下RPG的流行设定，DFQ自然也不例外。而掉落业务自然也有其值得细说之处，不然也就不会有本文了（笑）。接下来将一步步引申出随机掉落的实现演进。 粗劣的实现 在以往的开发生涯中，对于掉落业务，我采取了很粗劣的实现：12345678910111213local random = math.random() -- 0-1local pool -- drop poolif (random &lt; 0.1) then pool = pools.normalelseif (random &lt; 0.3) then pool = pools.rareelse pool = pools.otherendlocal index = math.random(1, #pool) -- Choice one.local item = pool[index] -- Get an item. 这种实现的槽点可谓数不胜数：掉落池的选取可谓暴力代码，而池中的道具也只能通过塞入相同的多份来扩充概率，对于概率的控制度很生硬。哪怕是将掉落池采取与道具相同的做法（将pools做成list）以去除暴力代码，对于概率控制度的问题依旧没有解决。且进行了两次取随机数，从概率而言并不纯粹。实际效果而言也导致了经常重复掉落，并不可取。 Alias Method 那么如果选择将多个掉落池合而为一，使之只有一个list呢？ 如此确实能让概率纯粹了，但是对于道具概率的控制度依然很差。这个问题可以通过构建道具概率表（{a = 0.1, b = 0.5, ...}）以生成掉落池（{a, b, b, b,...}）解决。但这样生成的掉落池未免也太大了（最后可能会达上千个元素），这太不环保了，那怎么办呢？ 长达廿二年的人生经验告诉我：我们做的绝大多数事情都是前人做过的，遇到不会的问题看看前人是怎么做的就对了。果不其然，这就遇上了个合适的算法：Alias Method。 本文并不打算详解其中的奥妙，这是愚蠢的复读机行为。直接上代码：123456789101112131415161718192021222324252627282930313233343536-- items: A list of probability of item.function Alias(items) local len = #items local alias = &#123;&#125; local probs = &#123;&#125; local small = &#123;&#125; local large = &#123;&#125; for n=1, len do items[n] = items[n] * len local tab = items[n] &lt; 1 and small or large table.insert(tab, n) end while (#small &gt; 0 and #large &gt; 0) do local less = table.pop(small) -- Remove the first element of list and return it. local more = table.pop(large) probs[less] = items[less] alias[less] = more items[more] = items[more] - (1 - items[less]) local tab = items[more] &lt; 1 and small or large table.insert(tab, more) end while (#small &gt; 0) do probs[table.pop(small)] = 1 end while (#large &gt; 0) do probs[table.pop(large)] = 1 end return alias, probsend 算法的代码量并不多，也就三十多行，输入参数items为道具的的概率list（{0.1, 0.1, 0.5, ...}），即代表需要配套的paths来表示对应的道具标识（{&quot;stone&quot;, &quot;potion&quot;, &quot;gold&quot;, ...}）。至于返回值alias, probs，先来看看获取随机掉落的代码：123local index = math.random(1, #paths) --- 1-nindex = math.random() &lt; probs[index] and index or alias[index]local path = paths[index] --- Item's path. 以上代码很好理解，首先随机获取一个道具的索引，根据索引获取到probs[index]的值，与随机数（0-1）比较，由此可见probs存放的是一种运算后的概率值。若是随机数大于概率值，索引则改为alias[index]，由此可见alias存放的是一种与原索引相对应的新索引，而新的索引自然会有对应的道具。 如此我们便可理解这套算法的做法了：为每个道具设置一个概率值以及相对应的另一个道具，随机到一个道具后，仍需二次随机进行二选一。这么做很好理解，就是将一些高概率的道具填充到一些低概率的道具里： 如图所示的第二项紫色的占比（概率）为1，表示不需要进行二次随机了，如此即可保证整个掉落池的概率是可以平分干净的（多出的部分就作为1概率项）。不得不说这种做法十分绝妙，完美解决了先前做法中掉落池元素过大的问题，美中不足在于需要进行二次随机，相对破坏了概率的纯粹性，但由于只是二选一，实际上效果是可接受的。 掉落池的维护 虽说Alias Method方案的掉落池配置变得相当容易，只需如此这般填写概率值即可，再分别生成items与paths：123456return &#123; ["equipment/weapon/sword"] = 0.3, ["equipment/weapon/knife"] = 0.3, ["equipment/weapon/katana"] = 0.3, ["skill/flash"] = 0.1&#125; 然而实际上掉落项的种类与数量都相当的多，并且会时常更改。所以这般直接的配置是无法满足需求的，于是演进为：12345678910111213141516return &#123; skill = &#123; prob = 0, item = &#123; flash = 1 &#125; &#125;, ["equipment/weapon"] = &#123; prob = 0.9, item = &#123; sword = 0, knife = 0, katana = 0 &#125; &#125;&#125; 新配置明显就方便了不少，若是概率填写为0则表示剩余总概率的平均值（sword=0 =&gt; 0.9/3 =&gt; 0.3），且填写的概率是相对于本层的（skill的总概率为0.1，故flash=1 =&gt; 0.1）。算是基于原配置进行了一波封装，可维护性大幅提升，如此便可面对变化频繁的需求了。 后记 本文所展示的掉落业务只是基础，在业界会有复杂度远超于此的需求（与时间、职业等因素挂钩，掉落池数量等），但DFQ的需求也仅此而已，期待日后能接触到更主流的设计。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在macOS搭建LÖVE for iOS平台]]></title>
      <url>%2F2019%2F03%2F01%2Fbuild_love_ios%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 继上回在macOS搭建LÖVE for Android平台后，这次买了新的iPhone，对iOS平台的发布自然也要开始了。如上回一般，也发现了不少实操中会遇到的问题，特此记录，以便后人。 实机调试 LÖVE for iOS的编译可谓相当容易，前提是你必须拥有一台macOS以及iOS设备，并且安装了Xcode。如官方教程所言般进行便是，大致上就是下载LÖVE源码工程，并且用Xcode打开love/platform/xcode/love.xcodeproj，然后选择love-ios项目、连上iOS设备、设置签名、然后Build就完事了。 如上图所示那便是签名的设置了，需要登录Apple账号作为Personal Team，并确保这是iOS设备所使用的账号。 签名设置完成无错误提示后，那便如上图所示般选择、执行即可。请确保iOS设备与macOS设备是处于连接状态的，过会便可见到iOS设备已将LÖVE安装完毕。此时尚无法直接运行，需要执行设置→通用→设备管理→Apple账号→信任love。 刚装好的LÖVE仍是空空如也，你可以选择打包好一个项目作为test.love，使用Apple的隔空投送（AirDrop）功能进行快速传输，如下图所示： 投送完毕后，iOS会精确的识别到这是LÖVE所需要的文件，于是你可以在LÖVE里见到它了，如下图所示： 画面适配 我所测试的项目的功能很简单：显示一张图片、该图片会拉伸至窗口大小。直接运行的效果如下图所示： 很明显可以得出两个问题：画面并不是水平的，以及顶部的状态栏没去掉。解决它俩的方法很简单，想要画面是水平的，就得在编译设置里进行更改，如下图所示： 如此即可，至于顶部的状态栏的去除，选择编译设置里的Hide status bar是无效的，因为LÖVE在游戏运行时又做了一次设置。而这个设置则是与引擎的love.window.setFullscreen(fullscreen)这个API有关，只需要在游戏运行时设置为全屏即可关闭状态栏。如此便没毛病了，如下图所示： 开发调试 在开发过程中需要不断地进行实机调试时，每次都对项目进行打包那效率未免也太低了。然而鉴于iOS的沙盒机制，又做不到如同Android般使用Git来进行同步工程。好在*.love文件本质上就是*.zip文件，如此开发一个对压缩包进行增量更新的脚本即可。如以下代码所示，用到了zip命令，脚本版本为Python3：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import osimport datetimeimport zipfilefrom os.path import realpath, dirnamedef listdir(path): paths = [] lst = path.split('/') tree = file_tree for i in range(len(lst) - 1): tree = tree[lst[i]] for k in tree: v = tree[k] p = k if v is True else k + '/' paths.append(p) return pathsdef zip(code): os.system("zip %s %s" % (file_name, code))def sync(path): is_file_a = os.path.isfile(path) is_dir_a = os.path.isdir(path) info = path in name_set and zip_file.getinfo(path) is_file_b = info and not info.is_dir() is_dir_b = info and not is_file_b if is_file_a: if is_dir_b: zip('-d %s' % path) if is_file_b: time_a = os.stat(path).st_mtime time_b = datetime.datetime(*info.date_time).timestamp() if abs(time_a - time_b) &gt; 1: zip(path) else: zip(path) elif is_dir_a: if is_file_b: zip('-d %s' % path) if is_dir_b: list_a = os.listdir(path) for i in range(len(list_a)): if os.path.isdir(path + list_a[i]): list_a[i] = list_a[i] + '/' list_b = listdir(path) list_merger = list(set(list_a + list_b)) for p in list_merger: sync(path + p) else: zip(path) zip('-r %s*' % path) else: if is_dir_b: zip('-d %s*' % path) elif is_file_b: zip('-d %s' % path)cwd = dirname(realpath(__file__))os.chdir(cwd)file_name = 'game.love'zip_file = zipfile.ZipFile(file_name, 'a')zip_file.close()name_set = set(zip_file.namelist())file_tree = &#123;&#125;for p in name_set: ls = p.split('/') tree = file_tree length = len(ls) for i in range(length): s = ls[i] if len(s) &gt; 0: if s not in tree: tree[s] = True if i == length - 1 else &#123;&#125; tree = tree[s]sync('asset/')sync('source/')# ... IPA发布 以上只能本机运行而已，若是想分享给他人，便要解决新的问题了。iOS的安装包为.ipa文件，你需要提供正式的开发者账号作为签名，方可生成之。开发者账号分为以下三种： 个人账号 只能提供单人使用 其他人若想运行ipa文件，需要注册其UDID 99美元/年 公司账号 允许多个开发者使用 需要填写公司的邓百氏编码(D-U-N-S Number) 其他人若想运行ipa文件，需要注册其UDID 99美元/年 企业账号 允许多个开发者使用 需要填写公司的邓百氏编码(D-U-N-S Number) 该账号下的APP不能发布到App Store 299美元/年 也就是说，除了企业账号以外，想轻松分享给他人是比较麻烦的。这方面可以考虑诸如蒲公英一般的第三方签名平台，会更方便。 IPA的生成方式为Xcode下Product→Archive，然后根据指示进行即可。顺带一提，在编译设置中将game.love文件加入到APP资源里，变会默认直接运行该项目，以达到发布的效果。如下图所示： LuaJIT 还有一个需要注意的问题是：Lua代码若是需要转为LuaJIT字节码，所选择的版本得是LuaJIT 2.1.0-beta2 64bit（在LÖVE 0.10.2下）。重点在于这个64位，由于Apple现行规定APP必须得是64位，于是连LuaJIT的字节码也必须同步。而想要生成64位的字节码，则必须编译出64位的LuaJIT，而这需要在编译时填写参数：make CFLAGS=-DLUAJIT_ENABLE_GC64。 后记 总的来说iOS平台较之Android在编译方面更为简单，毕竟是很稳定的平台与设施嘛。但在开发方面则有更多的繁文缛节，也算是福兮祸兮吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《DFQ》开发随录——随机地图]]></title>
      <url>%2F2019%2F01%2F30%2Fdfq_map%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 虽然先前未曾严明，但《DFQ》的全称为《DungeonFighterQuest》，由字面上便可得出，这是一款《DNF》的同人游戏，那么《DFQ》的地图自然向《DNF》看齐了。而《DNF》的地图众所周知，具有一定的复杂度，在以往的作品开发过程中便是采取了手动制作的方式，可谓十分的费时费力。于是在《DFQ》便采用了生成随机地图的方式，与市面上许多独立游戏的做法不谋而合，毕竟手动做地图实在是太辛苦了（汗）。本文便记录其中心得。 地图结构 如上图所示，这便是一张随机生成的地图，它拥有以下组成： 远景层：地图最底的背景，图中表现为山水。 近景层：地图较近的背景，图中表现为树林。 边上层：地图的上边界，拥有若干地图物件。 地表层：地图的地板，图中表现为草地。 边下层：地图的下边界，拥有若干地图物件。 活动层：地图的主体，拥有若干活动的地图物件。 在配置中以这种形式组成：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849return &#123; info = &#123; width = &#123;1440, 1280, 1024&#125;, -- 宽度随机选择 height = &#123;600, 736&#125;, -- 高度随机选择 theme = "lorien", -- 地图主体 type = "dungeon", -- 地图类型 bgm = "lorien", -- 背景音乐 bgs = "forest1", -- 背景音效 name = &#123; cn = "洛兰", kr = "로리엔", jp = "ロリエン", en = "Lorien" &#125; -- 用于显示的地图名称，拥有中日韩英四语 &#125;, floorHorizon = 327, -- 地表层起始Y坐标 scope = &#123; x = 16, y = 368 &#125;, -- 可行走区域起始坐标 far = "$A/far", -- 远景层 near = "$A/near", -- 近景层 floor = &#123; left = "$A/tile/0", middle = "$A/tile/2", right = "$A/tile/1", bottom = "$A/tile/3" &#125;, -- 地表层 sprite = &#123; -- 图片 up = &#123; "$A/flower/0" ... &#125;, -- 边上层 floor = &#123; "$A/grass/0", ... &#125; -- 地表层物件 &#125;, actor = &#123; -- 活动对象 down = &#123; "$A/tree/0", ... &#125;, -- 边下层 article = &#123; "$A/tree/1", ... &#125; -- 活动层 &#125;&#125; 接下来将对逐层进行分析。 远/近景层 远景层与近景层的机制完全一致，所以可以拿来一起说明。当然之所以会分为两个层次而非合并，是因为远景与近景关于摄像机移动时的相对移动速度不一样，以此形成纵深感。但在地图生成这一块，它们的机制是一致的：12far = "$A/far", -- 远景层near = "$A/near", -- 近景层 它们都是加载一张图片，然后根据地图的宽度进行平铺操作即可。在最后阶段会渲染成一张成品长图，这是一种优化方法。 边上层 边上层为地图的上边界，拥有若干地图物件。这里的地图物件与其他层的并不一样，在配置里它的划分是sprite，仅仅是单纯的图片罢了：123456sprite = &#123; -- 图片 up = &#123; "$A/flower/0" ... &#125;, -- 边上层&#125; 因为这些物件不需要与角色产生什么互动，最后也会如远/近景层一般，渲染成大块的成图。 关于物件的放置，会采取生成宽高为100的格子铺满整行，并随机在这些格子上放置物件，如下图所示： 边下层 边下层与边上层类似，但是生成的地图物件为活动对象(actor)：123456actor = &#123; -- 活动对象 down = &#123; "$A/tree/0", ... &#125;, -- 边下层&#125; 边下层的地图物件需要作为活动对象主要是因为某些物件会遮挡人物，所以需要采取靠近后透明化的措施。于是不方便作为单纯的图片。 物件放置方面与边上层一致，这里不再复述，如下图所示： 地表层 地表层即地图的地板，远/近景层类似，也是采取平铺的方针。但是在元素上更为多样：123456floor = &#123; left = "$A/tile/0", middle = "$A/tile/2", right = "$A/tile/1", bottom = "$A/tile/3"&#125;, -- 地表层 地表层的图片分为左中右下四种，左右两种为于地图边缘进行随机选择（左/右或中），中为默认选择，下为平铺Y方向。 除此之外，地表层还会拥有一些类似边上层的地图物件：123456sprite = &#123; -- 图片 floor = &#123; "$A/grass/0", ... &#125; -- 地表层物件&#125;, 这些物件也是不会与人物有所交互，最终与整个地表层渲染成大图。与边上/边下层类似，地表层物件的放置会XY平铺宽高为64的格子，以此放置： 活动层 活动层即地图的主体，活动对象的放置层，诸如障碍、宝箱、怪物等皆置于此。放置的规则与地表层物件一致，与地表层物件的不同之处在于，活动层存在一些拥有障碍的物件： 如上图所示，《DFQ》采用的障碍方式为传统的格子流，这种形式便于配合类似A星的寻路算法。但如此存在障碍格子与物件素材的匹配问题，这方面都需要手动设置好。以及需要警惕因障碍范围过大且恰好四周都是障碍物件围住了人物的情况，好在实际上并不存在这样的物件（障碍并不会很大），并不需要为此做特殊措施。 随机问题 在处理诸如物件放置的问题时，切忌采用遍历+随机数判断的形式。因为这是不符合概率论的（存在放置数量上限），如此便会导致地图左边的元素多于右边（右边存在轮不到的可能）。所以得采取将格子存储在一个list中，以list[math.random(1, #list)]的方式提取要放置的格子，如此即可保证几率均等了。 后记 对于一些需要个性添加的元素（地图特效、通行门、BOSS），一般会采取编写专门的处理函数进行添加。对于一些需要固定化的地图，也可以采取生成后输出成文件以加载使用。目前这套很明显的缺点在于无法生成崎岖不一的地形，不过目前暂无需求，且日后再看吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2018年度总结]]></title>
      <url>%2F2018%2F12%2F31%2Fsummary_2018%2F</url>
      <content type="text"><![CDATA[不知不觉中2018年即将过去了，与去年相同，特作总结，以为归纳。 今年的Blog总共写了14篇，较之去年的13篇算是相差不大。但内容方面则更为单纯了，简要说来便是：DFQ、网络同步、ECS、实践记录。期望明年能有新的花样。 今年的主要成果为对网络同步的涉猎，在帧锁定同步方面有《Brick &amp; Ball》，在FPS/TPS同步方面有TPSDemo。收获了不少同仁的赞可，但都算不上是正式项目的实践，只能有待机会了。 项目方面，《DFQ》的开发也算是正式进行了，这将是明年的总旋律。与今年类似，如无特殊情况则保持月更相关Blog。待最终完工开源后（也许）将会是一个很好的学习素材。 平常时刻也有与ChawDoe进行一些作业方面的研究，涉及到诸如强化学习、哈希表、寻路算法、词法分析、UNIX/POSIX API、OpenGL等方面，也是获益良多，作为巩固基础了。 总的来说，愈发感觉到计算机图形学是自己的待恶补项，以及3D游戏开发中的不少方面也值得实践，这将是明年的发展方向，期望在这些方面能有所建树，作出一些心得分享。 以上便是本人的2018年度总结，今年下半年以来的社会经济状况不是很好，祈祷明年能够回暖吧。 无双草泥马 2018.12.31]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《DFQ》开发随录——ECS]]></title>
      <url>%2F2018%2F12%2F27%2Fdfq_ecs%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 在阅读本文之前，你需要了解一下何为ECS框架，今年年初本人也对此进行了相关研究。到了实际开发时发现确实有此需求，遂应用之。本文便记录其中心得。 ECS的意义 在讨论实现细节之前，首先要弄明白一个关键问题：为何要用ECS？ 对于我而言，使用ECS的意义在于使用传统OOP方式构造一个高度复杂的对象集时异常困难。在我看来，高度复杂的对象集即「多衍生物、衍生物之间多多少少拥有些共性」的存在。游戏中于地图上活跃的对象便是如此，拥有多种形式（物体、特效、子弹、NPC、怪物……），而这些衍生物之间多多少少会拥有一些共性（怪物和NPC都要寻路），如何组织安排好这些功能是很麻烦的一件事。在以往的开发生涯中，这部分我重构过很多遍，尝试过各种形式（将通用的功能做成子对象之类的），最终发现：ECS便是解决此问题的绝佳利器。 实现要素 上图便是本项目ECS框架的结构了，大致介绍一二： Entity（实体）: Entity是对象的主体，Component的容器，在数据结构的形式上就是个哈希表。 Component（组件）: Component是数据的容器，与Data对接，提取相关数据。Component的形式多样，如Transform、Aspect、Input等。Component只有构造函数。 Data（数据）: 来自配置文件，其中定义了各Component的配置所需。可由Manager将Data作为参数创建Entity。 Group（群组）: Group以Component作为条件筛选出合适的Entity集合，如此便可使符合条件的Entity运作相应的业务。 System（系统）: 业务运作的主体，以Group进行筛选出合适的Entity以执行相应的业务。分为Enter, Init, Exit, Update, LateUpdate, Draw六个业务函数。System的形式多样，如Drawing、Life、Battle等。 Lib（库）: 存放通用业务函数之处，原则上以具体所需Component为参数，而非Entity，如Hitstop(attacker, identity, time)。如此是为明确函数调用条件，以及可以使Component分别来自不同Entity，实现一些特殊需求。Lib的形式多样，如AI、Battle、Effect等。 Manager（中枢）: 负责Group与Entity的管理，如AddComponent, DelComponent, NewGroup, NewEntity等。 Executor（执行）: 整套系统的执行者，负责导入System，定义System的执行顺序以及提供System的执行场所。 使用演示 以上便是ECS框架的组成元素了，接下来展示一下使用场景：123456789101112131415161718192021222324252627282930313233343536373839-- attributes.lualocal _ATTRIBUTE = require("actor.lib.attribute") -- Liblocal _Timer = require("util.gear.timer")local _Base = require("actor.system.base")local _Attributes = require("core.class")(_Base) -- Systemfunction _Attributes:Ctor(upperEvent) -- Filter _Base.Ctor(self, upperEvent, &#123; battle = true, attributes = true &#125;) self._timer = _Timer.New(1000)endfunction _Attributes:Update(dt) self._timer:Update(dt) if (not self._timer.isRunning) then -- List is from group. for n=1, self._list:GetLength() do local e = self._list:Get(n) -- Entity -- Component of Battle if ((e.battle and not e.battle.isDead) or not e.battle) then local attributes = e.attributes -- Component of Attributes _ATTRIBUTE.AddHp(attributes, attributes.hpRecovery) _ATTRIBUTE.AddMp(attributes, attributes.mpRecovery) end end self._timer:Enter() endendreturn _Attributes 可以看到，这是属性相关的System，它提供了每秒回复HP与MP的业务。拥有Battle与Attributes组件的Entity方可执行，并且了ATTRIBUTE这个Lib的函数。采用这种形式只需要将业务分割为一个个System，以不同的Component组成游戏对象即可达到极高的灵活度。对于高度复杂的对象集而言可谓绝佳的解决方案。 子对象问题 在开发的过程中，总会遇到诸如状态、技能、BUFF之类需要以子对象形式存在的情况。为此应当如何实现是ECS框架绕不开的一个问题。我曾尝试为他们也纳入至ECS框架中，但是这样会使得System的数量膨胀，而且并没有带来什么明显的好处（它们的独立性很高）。也曾试过为它们弄二级ECS框架，但感觉很刻意死板。最终领悟到了一点：ECS框架对我而言的意义，只是降低构建对象的复杂度，若是对象本身的复杂度并不高，采用OOP的方式完全可以接受。 后记 ECS框架我只用在了地图对象，其余部分（如UI）等都是采用传统的面向对象形式，因为他们的构成复杂度并不高，切忌犯了“为用而用”的错误。当然对于Unity那边而言，ECS的意义在于达到高性能（内存连续、非GC、高Cache命中率、多线程），这时候为了高性能是不得不用了。当然Unity的ECS框架我所涉猎并不多，有待后日挖掘。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TPS游戏网络同步总结]]></title>
      <url>%2F2018%2F12%2F02%2Ftps_sync%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 因友人的项目要做TPS联机对战游戏，本人遂对此进行了一番研究，经过四回的辗转反侧，Demo总算是做出来了。本次Demo是C/S一体化的设计，即服务端也是Unity做的（可选择1P兼任服务器或者将Unity以命令行模式运行于服务器）。网络模块采用了UDP+KCP，即先前BNB的强化版，而之所以没用UNet是因为之前搞出了乌龙所以换了现在这套，但序列化部分还是用的UNet。以上只是背景交代，本文仅聚焦于网络同步方面的细节。 实现思想 如果你对这方面有所涉猎，想必大致了解何为状态同步。市面上的大多文章将其与帧锁定同步对立而论，但本人认为两者并非是对立的存在，关于这点这篇文章讲的非常清楚，希望读者不要拘泥于形式。在阐述详细的实现思想之前，我们先来看看FPS/TPS游戏的需求： 非常迅速的操作反馈（若采用服务器应答后方有反馈的设计，很难达到要求，尤其是操作镜头） → 本地先行 个人体验第一（对于是否命中敌人与被命中不是很敏感） → 玩家之间看到画面情况不一致 ACT元素低（不存在ACT游戏的打击控制链，不需要帧判定） → 不需要精确到帧的同步 服务器权威（命中判定由服务器决定） → 服务端模拟游戏世界、同步验证 房间战斗（玩家人数不多） → 与MMORPG同步不同 相对同步（玩家之间的时间差不可拉得太大） → 追赶进度 Well done，由以上几点需求已经得出了TPS游戏同步的实现思想，下文将根据实现思想阐述具体实现细节。 快照 在探究同步流程之前，首先要了解同步的核心：快照。换言之，也就是我们所同步的内容。快照（Snapshot）通俗来讲就是玩家的操作指令与相关数据的集合，由于需要做同步验证，所以将数据分为必要数据(Must)与验证数据(Check)，先来看看移动的快照数据结构吧:123456789// Actor/Common.cspublic class Move &#123; public string fd; // Address:Port(Must) public int frame; // Game Frame(Must) public bool fromServer; // It is from server, or client?(Must) public Vector3 velocity; // Moving Velocity(Must) public Vector3 position; // Position before moving(Check)&#125; 如上文所示，position为移动前的坐标，像这类数据客户端是不需要上传的，仅用于与服务端传来的快照作对比，以进行同步验证。 同步流程 由于服务端模拟游戏世界，所以采用了C/S一体化的设计。在代码层面上则是分为ServerMgr与ClientMgr两个MonoBehaviour，ServerMgr负责收集客户端的快照并整合下发，而ClientMgr负责发送快照与模拟来自服务端的快照以驱动同步单位的运行。如下图所示: 图中所说的同步快照，是一种特殊的快照列表，它由服务端每帧打包，包括了多个客户端的一帧快照，客户端模拟它们即可驱动其他客户端代表的对象。采用这种同步流程只能保证在客户端是同一帧生成的快照，在服务端也会打包到同一个同步快照里。除此之外都不会保证（不会考虑到快照之间的帧间隔执行情况），即不需要精确到帧的同步。 追赶进度 在正常的同步过程中情况总是理想的，但是一旦出现网络延迟或卡住的话，在恢复之时便会面临大量的快照，那么按照现有的做法便会导致与其他玩家的时间轴拉得太远（看到的画面是很久以前的了），这便需要设计追赶进度的机制。需要注意的是，追赶进度是服务端与客户端都需要的（服务器也有网络延迟和卡住的可能），客户端的追赶处理相当简单，同步快照超过一个数量则循环模拟:12345678910// ClientMgr.csif (this.syncList.Count &gt; 0) &#123; this.Simulate(); // SYNCMAX = 15 while(this.syncList.Count &gt; SYNCMAX) &#123; this.Simulate(); &#125;&#125; 服务端方面则较为复杂，简而言之就是要知道每个客户端快照列表有多少帧（如4个快照，帧号分别为1, 2, 2, 3，则为3帧），当某个每个客户端快照的帧数过高，则循环打包到同步快照列表:123456789101112131415161718192021// ServerMgr.csvar list = new List&lt;Snapshot&gt;(); // sync-snapshot// Foreach all clients.foreach (var i in this.unitMap) &#123; int frame = -1; var sl = i.Value.list; // INTERVAL = 10, i.Value.count that is count of frame. while (sl.Count &gt; 0 &amp;&amp; (i.Value.count &gt; INTERVAL || (frame == -1 || sl[0].frame == frame))) &#123; var s = sl[0]; list.Add(s); sl.RemoveAt(0); if (frame != s.frame) &#123; frame = s.frame; i.Value.count--; &#125; &#125;&#125; 本地先行 本地先行可谓这类同步最玄学之处，不过只要了解其原理倒也无甚。需要本地先行的理由在上文已经阐述，由于是以服务端权威且不那么介意判定的问题，所以是可以允许玩家之间看到画面情况不一致这种情况的。况且在大多数场合下，玩家先行并不会造成什么问题（最终的结果趋于一致），但假设在这么一个场合下：玩家A一直行走，在玩家B的视角里对玩家A进行了眩晕。如此便会造成不同步了，所以需要进行同步验证以将问题修正。 要实现同步验证的思路倒也朴素:就是用一个验证列表将快照保存，当收到同步快照列表时就进行逐个对照（对比它们的验证数据，见前文），一旦发现不一致之处，就以当前位置开始，循环模拟同步快照，然后再继续循环模拟验证列表里进度比目前快的快照，追上最新进度:12345678910111213141516171819202122232425262728// ClientMgr.cs// Compare sync list and check list.for (int i = 0; i &lt; list.Count; i++) &#123; if (!list[i].Equals(this.checkList[i])) &#123; index = i; print(i); break; &#125;&#125;if (index == list.Count) &#123; // Agreement this.checkList.RemoveRange(0, list.Count);&#125;else &#123; // Need to fix. var frame = list[list.Count - 1].frame; // Remove useless snapshots. for (int i = this.checkList.Count - 1; i &gt;= 0; i--) &#123; if (this.checkList[i].frame &lt;= frame) &#123; this.checkList.RemoveAt(i); &#125; &#125; // Loop simulate. ClientMgr.Resolve(this.fd, list, index); ClientMgr.Resolve(this.fd, this.checkList, 0);&#125; 服务端权威 从上文可以看出，本地先行会修正的范围只有本地玩家而已，回到之前的例子:在玩家B的视角里对玩家A进行了眩晕，假设这个行为在服务端上并没有达成（玩家A闪现走了），那么该如何修正呢？很显然可以选择搞个更大的修正系统，但我认为这样并不符合业界的常规做法，所以我给出的答案是: 眩晕行为需要在服务端触发了，然后由服务端将其作为快照，以正常同步的形式在诸客户端上展示。事实上在网络正常的情况下，这样的间隔最多也只是0.1x秒左右而已，完全可以接受。当然这么做对于玩家B而言肯定会发生修正（眩晕按理来说是之前的事了），所以我对此作了个措施: 为快照设计了fromServer属性，一旦是fromServer = true且属于本地玩家的快照，本地玩家会直接模拟而不会将其进行修正对比。这也可以看出这套同步的一个规则:会影响他人的操作，都需要由服务端发起。 后记 很显然，目前这个demo仍很不成熟，不少地方在业界应该会有更好的处理，如CS的射击纠正（服务端根据客户端的射击时间回滚之前的场景进行判定）。如此只能算是一个雏形，还是缺少实战项目的淬炼，先根据接下来的项目看看效果吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《DFQ》开发随录——界面]]></title>
      <url>%2F2018%2F10%2F29%2Fdfq_ui%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 在游戏开发的领域里，界面（User Interface）是不可或缺的，在一些强大的游戏引擎会为其配备一套解决方案。和之前的一系列问题一样，LÖVE自然是不会提供的，所以又得自己折腾一套了，本文便记录其中心得。 层级 许多年前，因我年少没经验，写UI都是逐个显示对象并填写参数的。捞的嘛就不谈了，所以也就深刻意识到面向对象以及建立层级体系的重要性。所谓层级体系，也就是将显示对象之间根据需求建立起上下级关系，下级的显示数据会基于上级（如上级移动了坐标，下级也会随之改变），这种玩意在Cocos我称之为Layer-Node体系（如下图所示），在Unity则是以Transform组件实现。欣慰的是，在LÖVE11.0也追加了Transform，同时不幸的是，我用的是旧版本，所以最终是自己造了一遍轮子:( 在设计上我首先实现了集显示与层级管理于一体的对象——Renderer，不过在实现上有点用力过猛，把Shader的层级管理也做了（下级的Shader会与上级的合并）。完成了这个核心之后，再分别设计基本的显示元素（Sprite、Animation、Particle、Label、Layer），不过我并没有另它们继承Renderer，而是设计了一个基类，并将Renderer作为成员对象存在，主要是Renderer的信息量过大，实是不宜直接继承了。结构如下图所示: 焦点 要说UI对象与一般的显示对象最大的不同之处，那便是会接收来自玩家的触控输入了，尤其是作为手机游戏，会同时受到多个触控。再涉及到图层等问题后，便有必要建立一个焦点管理体系了。首先UI对象需要提供判定触控，以及按下、持续、弹起的接口。然后在UIManager提供接收触控输入、焦点管理、对象运行的服务。流程如下图所示: 至于“判定触控所在坐标是否有符合条件的对象”这一需求的实现，便与上文提到的层级体系相得益彰了:显示顺序为从尾到头，而判定自然也是从最顶部的显示对象开始的，于是乎只要将Layer的成员从尾到头遍历判定即可。至于不想参与判定的对象会设置专门属性跳过。 MVC 这个便是老生常谈的设计模式了，去年我也对此作了一篇文章。简要来说便是，UI对象只负责接收输入（Controller）以展示结果（View），UI对象所保存的数据为展示而服务，真正的数据保存在来源对象（Model）。示例如下图所示（这里的Event按照C#的Event去理解即可）: 当然以上只是个人的理解，在我看来Controller即Model与View的桥梁，只要符合这个性质的存在即为Controller，它不一定是个固定的形式。包括按钮的按下处理函数这样的存在只要是由外部传入的，那么它也算是Controller。 配置 都8012年了，自然不可能以手写代码的形式创建UI布局，配置化自然是理所当然的:1234567891011121314151617181920212223242526return &#123; name = "mapName", script = "advanced/mapName", x = 1100, y = -30, subject = &#123; &#123; name = "bottom", script = "sprite", sprite = "mapName" &#125;, &#123; name = "label", script = "label", font = "normal/18", color = &#123; red = 241, green = 218, blue = 157, alpha = 255 &#125;, x = 90, y = 42 &#125; &#125;&#125; 通过这般类似HTML的方式进行编写配置文件，交给专门的创建函数处理即可，具体的数据处理方式则交由对应的类（script）处理。若是开发了相应的UI编辑器还可以直接制作生成配置，很显然这里也是契合了层级体系，可见其重要性。 后记 目前这套界面体系还缺乏相应的编辑器以及没有自适应布局的功能，不过实际上我也不太需要这些。只能说面向内部与面向公众的要求级别是不一样的，所以这并不能代表通用UI库的设计思想，仅供参考而已。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在macOS搭建LÖVE for Android平台]]></title>
      <url>%2F2018%2F08%2F24%2Fbuild_love_android%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 近日在搭建macOS下的LÖVE for Android遇到了不少问题，虽然有官方Wiki的帮助，但却发现了不少实操中才会遇到的问题，特此记录，以便后人。 JDK 由于安卓SDK只支持到了JDK8，所以只好装JDK8，新版将无法打开安卓SDK。可选择前往官网或者使用Homebrew下载。使用Homebrew如此输入便可：12$ brew tap caskroom/versions$ brew cask install java8 SDK 由于谷歌的尿性，安卓SDK的官网上已无合适的安卓SDK提供下载了，只剩下Android Studio和Android SDK命令行工具。此命令行工具实际上缺少了不少东西，所以也不推荐。本人推荐前往AndroidDevTools进行下载，认准SDK Tools项便是。 下载完成后便需要安装各种工具了，使用命令行运行SDK/tools目录下的android即可打开SDK安装界面，然后按照官方Wiki所言般安装相关工具即可。 值得一提的是Android Support Library，在谷歌官方源似乎已经找不到了，可以考虑换源或者直接下载官方文件，下载完成后置于SDK/extras目录下即可。 NDK 这里官方Wiki便开始坑人了：Once you have the SDK tools you can get the NDK version r9d from here (Download acording to your system).事实上r9d会因为某个部件版本过低而对接失败，必须是小于15大于9的版本。去AndroidDevTools下载即可。 Ant 这个没什么坑点，照常下载即可。不过ant将会作为一个常用命令去使用，所以推荐在Homebrew进行安装：$ brew install ant即可。 环境变量 把love-android-sdl2下载后（当然我使用的是0.10.2版本，所以下载的是这个），仍需要配置环境变量，参考官方Wiki即可。大致上是在~/.bash_profile文件添加SDK与NDK的路径：12export ANDROID_HOME=/Developer/SDKs/android-sdk-macosxexport ANDROID_NDK=/Developer/Tools/ndk 然后是在/etc/paths.d/android-sdk文件添加SDK的tools与platform-tools以及ant的bin目录：123/Developer/SDKs/android-sdk-macosx/tools/Developer/SDKs/android-sdk-macosx/platform-tools/Developer/Tools/ant/bin 编译 环境变量部署完毕后，便可以开始编译LÖVE for Android工程了（ndk-build是NDK文件夹下的一个工具）：12$ cd ~/repos/love-android-sdl2$ ndk-build 若是一切平安无事的话，便接近大功告成了！ 发布 首先需要在LÖVE for Android目录下新建assets文件夹，然后将游戏打包命名为game.love并放置过去。然后在LÖVE for Android目录下执行$ ant debug即可，稍等便会于bin目录下生成apk文件。 当然这样生成的apk文件与从官网直接下载的APK包外表无异，所以仍需要定制化，参考此篇即可，不再复述。 后续问题 由于在大多数硬盘格式上是不区分大小写的，而到了.love文件下则会区分。这点需要仔细检查。 由于LÖVE for Android使用的LuaJIT版本为2.1，而普世平台（Windows/macOS/Ubuntu）使用的版本还在2.0.4，而2.1与2.0的字节码无法兼容，所以需要使用2.1版本进行生成。 在手机上对于GLSL的格式要求更为严格，详情参考此篇，总体来说便是：不要写整数，小数点结尾也不要带f。 后记 其实当年也曾在Windows系统部署过，却未曾有现在这般多坑，可见流行系统也有流行系统的好处啊。这篇文章似乎都可以投稿到他们仓库了呢（笑）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《DFQ》开发随录——资源管理]]></title>
      <url>%2F2018%2F07%2F27%2Fdfq_res%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 在游戏开发的领域里，游戏资源的管理可谓一个很重要的基础功能，在一些强大的游戏引擎会为其配备一套解决方案。而LÖVE很不幸的再次没有提供，好在即使没有也起码做好了内存管理的工作，那么即便自己动手做一套也不是什么困难的事了，本文便记录其中心得。 资源管理模块本质上只做了两件事： 生命周期管理：保证多次加载时资源的复用，在无需该资源时进行销毁。 配置接口：提供加载资源的API，以及外部化的资源配置。 接下来便围绕以上两点展开说明其中的要点。 生命周期管理 如上文所言，生命周期管理要做的事即：保证多次加载时资源的复用，在无需该资源时进行销毁。资源复用的实现思路非常的简单，使用哈希表将资源以路径-对象为映射关系进行存储即可，然后每次加载资源时进行一次检查，若存在表内则直接获取，否则再进行读取。 12345678910111213local poor = &#123;&#125;local function GetResource(path) if (poor[path]) then return poor[path] end local res = open(path) --... load resource. poor[path] = res return resend 接下来是第二个问题：在无需该资源时进行销毁。说得具体点便是：当外部没有对象引用该资源时，将其从资源池里移除。如此只需要使用弱引用即可，在Lua里即是建立弱表（weak table）。 12local poor = &#123;&#125;setmetatable(poor, &#123;__mode = 'v'&#125;) 如此当poor内存在外部无引用的对象时，在垃圾回收时便会将其移除。如此资源的生命周期管理便算完成了。 配置接口 资源文件按照性质可以划分为两种：数据文件（二进制为主，如图片、声音等），配置文件（可编辑、可序列化的变量对象）。对于配置文件，Lua可以很方便地直接使用本体： 1234return &#123; x = 1, y = 2&#125; 只要将其读取后使用loadstring(text)()函数便可将其序列化，在其他引擎也有自定义配置格式以编辑器加持的形式解决，如Unity。现实情况中，一般数据文件会通过配置文件进行加载，即在配置文件提供对应资源的路径，然后由代码进行加载处理。 1234567891011return &#123; image = "glow", ox = 5, oy = 5, color = &#123; r = 255, g = 255, b = 255, a = 127 &#125;&#125; 如上配置所示，此配置的image项将会由代码根据配置提供的路径glow进行读取对应目录下的image/glow.png文件。如此便可看出，资源与资源之间存在很强的联动性，它们就像是一棵树，节节相扣。对于那些较上层的配置文件而言，往往会从上到下牵涉巨多资源。这么做是很棒的，一加载便将所有相关的资源都加载了，只要在恰当的场合进行资源加载（如切换地图），核心游戏过程中则几乎不会涉及到加载了。 配置的健壮性 在没有编辑器加持的情况下，单纯的配置文件健壮性是有限的，最突出的两个需求便是： 快捷定位路径：如位于sprite/test/1.cfg的配置文件想要读取位于同路径、不同分类下的image/test/1.png文件，如果没有一些辅助手段，那么只能傻傻的输入全路径，十分愚蠢。 参数注入：倘若存在一些大体相似，少部分不同的配置需求，若没有参数注入，那么只好傻傻的批量复制修改，也是十分的愚蠢。 当然以上两点若是存在编辑器，自然可以无视并通过自动化手段之类达到相同的效果。但目前项目暂无编辑器，于是采用了替换文本的方案。 123456---sprite/test/1.cfgreturn &#123; image = "$A", sx = $1, sy = $2,&#125; 如上配置所示，$A便是代表当前资源分类下的路径，即替换为test/1，如此便可快速定位至image/test/1.png，算是一种语法糖吧。至于$1 $2则代表第1、第2个注入的参数，在调用的API的时候会以{1.2, 1}的形式作为参数填入。如此便会将$1替换为1.2，同理$2替换为1。当然这种注入了参数的配置在资源池的key是不能使用路径的（不是标准的），会在其后加入参数值成为：test/1|1.2|1。 配置的只读性 由于资源对象往往都是独一一份，到处引用，倘若哪处不小心对其进行了修改，那么便会引起连锁反应影响全局。所以有必要考虑将资源对象设置为只读的： 1234567891011121314151617181920212223242526272829303132333435local function _PrivateTips() assert(nil, "The table is const.")endfunction _TABLE.NewConst(tab) local tabMt = getmetatable(tab) if (not tabMt) then tabMt = &#123;&#125; setmetatable(tab, tabMt) end local const = tabMt.__const if (not const) then const = &#123;&#125; tabMt.__const = const local constMt = &#123; __index = tab, __newindex = _PrivateTips, __const = const &#125; setmetatable(const, constMt) end for k, v in pairs(tab) do if (type(v) == "table") then tab[k] = _TABLE.NewConst(v) end end return constend 只要将对象拿去处理后，试图修改该对象时将会报错。当然这样做是有代价的：pairs()和table.getn函数将会变得无法直接使用，需要取出其元表方可使用。所以需要配备专门函数： 12345678910111213141516171819function _TABLE.Len(tab) local meta = getmetatable(tab) if (meta and meta.__index) then return #meta.__index else return #tab endendfunction _TABLE.Pairs(tab) local meta = getmetatable(tab) if (meta and meta.__index) then return pairs(meta.__index) else return pairs(tab) endend 这样子使用起来虽然麻烦了点，不过的确将资源对象和一般对象作出了明显的区分。另外只读处理的时机也需要考量的，一般得在整个资源对象处理完毕后才进行。 配置的个性化 对于一些普遍的资源文件（图片、声音、精灵、动画等），一般配备专属的处理函数即可。但是到了业务层面情况往往会繁杂许多，将会存在许多个性化的配置格式。这时候便需要将业务对象和资源对象进行绑定： 123456789101112131415161718return &#123; script = "$A", tagMap = &#123; attack = true, attackRate = true, autoPlay = true &#125;, stopTime = 200, endTime = 300, nextState = "stay", frameaniPath = "$0attack1", actor = "bullet/throwstone", bulletPos = &#123; x = 20, y = 0, z = -60 &#125;&#125; 如上配置所示，这是一个哥布林的投掷状态，这里的配置便需要提供子弹资源以及发射坐标了。关于这些个性化的配置项，将会如此解决： 123456789101112local function _NewStateData(path, keys) local data, path = _RESOURCE.ReadConfig(path, "config/actor/state/%s.cfg", keys) data.class = require("actor/state/" .. data.script) data.script = nil if (data.class.HandleData) then data.class.HandleData(data) end return dataend 可以看到，通过配置的script项找到对应的脚本业务对象，然后调用其对象的HandleData函数进行解析。如此便解决了个性化的问题。 后记 还是如上篇一般，这个问题对于流行的大引擎而言已经提供了成熟的解决方案。上了贼船呀，只能走到黑了。不过造造轮子也是有益技术的提升的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《DFQ》开发随录——图集]]></title>
      <url>%2F2018%2F06%2F23%2Fdfq_sheet%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 在游戏开发的领域里，图集（SpriteSheet）是一个很重要的概念，其好处在链接处也已言明。但若是引擎没提供相关的支持，那么便需要自己搞个解决方案了。而LÖVE也恰好是没有提供相关支持的，那么只好自己动手丰衣足食了，本文便记录其中心得。 装箱问题 要实现图集的核心便是对图片进行拼合打包，其实类似的工具市面上亦有存在（如TexturePacker）。从功能上而论，TexturePacker完全可以满足需求（有提供命令行模式，可实现自动化）。可惜TexturePacker的免费版根本不堪使用，而破解也相继失败。而其他类似的工具要么无法满足需求，要么不支持macOS。只好自己手写一套了。 实现的图集的难点无非在于拼合时图片排列的算法，由Claris告知得这种属于装箱问题，目前并无最优解。由装箱问题为关键字进行展开搜索，发现一种名为MaxRectsBinPack的算法可解决问题，我将之翻译成了Python版。如此装箱问题便解决了。 拼合问题 接下来的问题便是“谁和谁拼合成一张图”了，我对此立下三个原则： 关联性不高者不拼（拼成大图的代价便是成为资源共同体，如果关联性不高的拼合一块则会造成极大的内存浪费） 黑底与透明者不拼（黑底图拼成大图必须得保证全图无透明点，否则游戏里会出现奇怪的线条） 拼合后过大者不拼（需保证图片大小在4096*4096及以下，否则恐怕出现上限问题） 以这三原则来看，是无法做到以文件夹为单位进行粗暴的拼合了。所以采用了编写配置的方式进行。 12345678910111213141516"effect": &#123; "map": &#123; "lorien": [ "lorien", "/actor/article/lorien/pathgate", "/actor/article/lorien/largegrass" ] &#125;, "death": [ "death", "dieFlash" ], "buff": &#123; "freeze": "freeze" &#125;&#125; 配置以JSON形式存储，配置中的key代表着合图文件夹的层级，value则为欲拼合的图片文件夹，若无/开头则代表以当前文件夹层级为路径，反之则为全路径。以这套方案便可很自由地选择拼合的方案了。 配置问题 图片的拼合问题解决后，便是游戏要如何以最低的代价去兼容新的图片形式了。解决方案自然是为原图片生成路径一致的配置文件，游戏通过读取配置文件以无缝对接新的图片形式。配置文件格式如下： 1234567return &#123; image = "ui", x = 0, y = 151, w = 45, h = 41&#125; 配置文件记录了所属合图的路径以及在合图中的坐标宽高，如此便可清晰无比地取得了。由于Python的lupa模块装不上，为此还专门写了个Lua与JSON的转换器。 大小问题 一般而言，因为光栅化需要对纹理采样进行快速取值，图片大小需要遵循2的N次幂（256、512、1024…）。这种符合的图片被称为POT(Power-Of-Two)，同理不满足的称为NPOT(Non-Power-Of-Two)。在早期POT纹理可以说是必须的，而今在OpenGL ES2.0后支持了NPOT。但为了能满足ETC压缩以及兼容性，个人推荐还是对合图进行POT化。 后记 其实从这个问题来看，选择流行的大引擎的确会更为方便。在Unity里可以由后台自动完成的事情现在却要一篇文章来总结，不过贼船已经上了，就只能走到黑了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lua的local变量探究]]></title>
      <url>%2F2018%2F04%2F17%2Flua_local%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 先前看到用好Lua+Unity，让性能飞起来—LuaJIT性能坑详解一文中提到： 3.2 寄存器分配失败-&gt;减少local变量、避免过深的调用层次 很不幸的一点是，arm中可用的寄存器比x86少。LuaJIT为了速度，会尽可能用寄存器存储local变量，但是如果local变量太多，寄存器不够用，目前JIT的做法是：放弃治疗（有兴趣可以看看源码中asm_head_side函数的注释）。因此，我们能做的，只有按照官方优化指引说的，避免过多的local变量，或者通过do end来限制local变量的生命周期。 对此自然是可以理解的，哪怕是一般语言，local变量过多也会有堆栈溢出的问题。不过我对此一直有个隐忧：Lua是拥有模块级local变量的，不知是否也受此规则影响？尽管有此隐忧，却一直没有去做相关的探究。恰逢今日遇到相关话题，便来个刨根问底吧。 200限制 首先的发现是：一段过程下最多拥有200个local变量，且do end不算。类似这样： 1234567local Class = &#123;&#125;local test1 = 1local test2 = 2... --to 199return Class 如果超过199，则会报出main function has more than 200 local variables的错误。当然这里说的是一段过程，所以函数是另算的，同样一个函数的过程最多也不能超过200个local变量（调用函数则算转入下一个过程了）。 这个限制是Lua与LuaJIT共有的，显然是想限制local数量的泛滥。 函数嵌套调用 接下来便是试试函数嵌套调用了： 12345678910function Class.Do(v) if (v &gt; n) then --n is a custom value return end local test1 = 1 ... -- to 199 Class.Do(v + 1)end 注意参数v也算是local变量的一员，所以test变量最多只能延伸到199个。以此进行递归调用的话，根据实验结果来看： 版本 嵌套上限 local变量上限 LuaJIT 325 65000 Lua5.3 4975 995000 测试的环境为macOS x86-64，LuaJIT方面无论JIT开启与否结果皆一致。根据前文所言来看，到了ARM环境这个数量将会进一步下降。虽然从对比来看差距有点大，但实际上在函数调用方面也算够用了。 模块级local变量 接下来便是我最关心的一点了：以上local变量上限是否会影响到模块级local变量？所谓模块级local变量即作用域为整个文件： 1234567--test.lualocal Class = &#123;&#125;local function Func()end...return Class 这种模块级local变量在Lua开发的应用还是很广泛的，它能有效的做到信息分隔的效果。但若是这些变量也受之前的上限规则影响，咁就扑街了！ 首先是测试加载多个满载local变量的模块： 123for n=1, 5000 do require("test" .. n)end 天可怜见，无论读取多少个文件，都不会存在上限问题。可见对于模块级local变量的处理是不一样的。到了这里基本上可以放心了，不过为防万一，我还做了模块的嵌套引用实验： 123456789---test1.lualocal Class = &#123;&#125;print("1")local Next = require("test2")local test1 = 1local test2 = 2... --to maxreturn Class 以这种形式生成了5000个文件，以此进行嵌套引用，结果也是成功通过了。由此可见，对于模块级local变量是可以放心地去使用了。 后记 尽管模块级local变量是可以随便用了，但是也要考虑到热更新方面的问题：若是选择使用模块级local变量去存储模块的数据，那么在热更新方面的处理将会变得十分麻烦。从这点考虑的话，模块级local变量最好只是用于引用别的模块为妙。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ECS框架的初步探究]]></title>
      <url>%2F2018%2F03%2F19%2Fecs_first%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 在阅读这篇文章之前，你需要了解一下何为ECS框架。关于ECS框架，其实近年来一直想去尝试，终于在近日有所体悟，遂有此文。 详解 ECS框架的存在实际上很早就出现了（我记得最初在2003年），近年随着《守望先锋》架构设计与网络同步一文出现后瞬间成了炙手可热的新星。 ECS框架与帧同步锁定类似，皆只是拥有一个概念，但无确切的实现标准。但事实上已经不少现成的实现（如Entitas），不过我觉得Entitas在与Unity的结合上不符合我的审美，于是自己动手造了个轮子。 ECS框架的概念其实相当直观：Entity-Component-System三件套。 Entity即实体，作为Component的经纪人，可拥有多个Component。 Component即组件，作为数据存储的容器，原则上只包含内部数据自处理的函数。Component以Entity作为标识，以此判断所属。 System即系统，作为业务函数的集合，会与Component对接实现业务运行（System处理Component）。 以上三点可谓看过相关文章的都懂，只是落实到具体实现上仍会有不少不明不白之处（Entity是作为容器还是标识符？Component可否嵌套Component？System之间可否相互调用？）。以上问题并没有确切的答案，只能是落实实现时根据需求而定。 实现 所谓实践出真知，在此之前我写了个贪吃蛇，这是个不错的素材，于是便将其ECS化。这下也可将两者进行对比，品味其中区别。 Entity 由于这款游戏是使用Unity制作的，那么自然最好与Unity本身相结合。我首先考虑到的便是与Unity本身的GameObject-Behavior（其实是Component，为防误解，特此改称）框架结合（业务环境下有调用它们的需求），于是选择将Entity做成一个Behavior： 123456789101112131415161718192021using System;using UnityEngine;namespace Game.Core &#123; public class Entity : MonoBehaviour &#123; public static event Action&lt;Entity&gt; NewTickEvent; public static event Action&lt;Entity&gt; DestroyTickEvent; protected void Start() &#123; if (Entity.NewTickEvent != null) &#123; Entity.NewTickEvent(this); &#125; &#125; protected void OnDestroy() &#123; if (Entity.DestroyTickEvent != null) &#123; Entity.DestroyTickEvent(this); &#125; &#125; &#125;&#125; 可以看出，Entity的生命周期也与GameObject进行了捆绑，并且设置了两个event令System可以进行监控。 再来看看Entity的具体实例： 1234567891011121314151617181920using UnityEngine;namespace Game.Entitys &#123; using Core; using Components; public class Food : Entity &#123; public Position position = new Position(); protected void Awake() &#123; this.position.Init(this); &#125; protected new void OnDestroy() &#123; base.OnDestroy(); this.position.Destroy(); &#125; &#125;&#125; 可以看出Food实体创建了一个Position组件，托Unity编辑器的服，我们可以清晰地看到Position的数据构成，并可方便地进行编辑（包括运行时）。当然可以看得出这里Component的创建方式相当别扭（实例化后仍需Init），这是为了对接Unity的序列化功能，若不这么做的话，某些数据将会序列化失败（如Collision Slot）。 Component Component的初始实现便很简单了，只需要对接Entity以及预留Init与Destroy接口即可： 123456789101112131415using System;namespace Game.Core &#123; [Serializable] public class Component &#123; [NonSerialized] public Entity entity; public virtual void Init(Entity entity) &#123; this.entity = entity; &#125; public virtual void Destroy() &#123;&#125; &#125;&#125; 这里令Component拥有entity是为了便于识别身份，[Serializable]标识表示该对象可序列化（与编辑器交互），[NonSerialized]标识表示不让该变量序列化（没有显示在编辑器的需求）。接下来看看Position组件的具体实现： 12345678910111213141516171819202122232425262728using System;using System.Collections.Generic;using UnityEngine;namespace Game.Components &#123; using Core; using Solts; public class Position : Component &#123; public static Dictionary&lt;Entity, Position&gt; Map = new Dictionary&lt;Entity, Position&gt;(); public static List&lt;Position&gt; List = new List&lt;Position&gt;(); public Vector2Int value; public Collision collsionSlot; public override void Init(Entity entity) &#123; base.Init(entity); Position.Map.Add(entity, this); Position.List.Add(this); &#125; public override void Destroy() &#123; Position.Map.Remove(this.entity); Position.List.Remove(this); &#125; &#125;&#125; 关于ECS框架有一个很普遍的问题：在System要如何获取到Component？我的解决方法便是为有获取需求的Component设立存储容器，当然这种写法有点死板，应该专门设立容器管理类进行自动化处理，这是个可改善的方向。 System System纯粹来看便是个函数集，在Entitas的实现是专门设立Behavior装载System以运行。而我选择分离：System即Behavior，两者倒没什么根本上的区别，全凭个人喜好罢了。在以Behavior的实现下并不需要System基类，以下以涉及到坐标与碰撞的Field系统为例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576using System.Collections.Generic;using UnityEngine;namespace Game.Systems &#123; using Core; using Components; using Entitys; public class Field : MonoBehaviour &#123; public const float SIZE = 0.32f; private static List&lt;Entity&gt; SyncList = new List&lt;Entity&gt;(); public static Vector2 ToPosition(int x, int y) &#123; return new Vector2(x * SIZE + SIZE * 0.5f, y * SIZE + SIZE * 0.5f); &#125; public static void AdjustPosition(Position position, Transform transform=null) &#123; transform = transform == null ? position.entity.transform : transform; transform.position = Field.ToPosition(position.value.x, position.value.y); &#125; private static void Collide(Position a, Position b) &#123; if (a.value == b.value) &#123; if (a.collsionSlot != null) &#123; a.collsionSlot.Run(a.entity, b.entity); &#125; if (b.collsionSlot != null) &#123; b.collsionSlot.Run(b.entity, a.entity); &#125; &#125; &#125; private static void Sync(Position position, Joint joint) &#123; joint.laterPos = position.value; &#125; protected void Awake() &#123; Entity.NewTickEvent += this.NewTick; Entity.DestroyTickEvent += this.DestroyTick; Director.UpdateTickEvent += this.UpdateTick; &#125; private void NewTick(Entity entity) &#123; bool hasPos = Position.Map.ContainsKey(entity); bool hasJoi = Joint.Map.ContainsKey(entity); if (hasPos) &#123; Field.AdjustPosition(Position.Map[entity]); &#125; if (hasPos &amp;&amp; hasJoi) &#123; Field.SyncList.Add(entity); &#125; &#125; private void UpdateTick() &#123; for (int i = 0; i &lt; Position.List.Count; i++) &#123; for (int j = i + 1; j &lt; Position.List.Count; j++) &#123; Field.Collide(Position.List[i], Position.List[j]); &#125; &#125; foreach (var entity in Field.SyncList) &#123; Field.Sync(Position.Map[entity], Joint.Map[entity]); &#125; &#125; private void DestroyTick(Entity entity) &#123; if (Field.SyncList.Contains(entity)) &#123; Field.SyncList.Remove(entity); &#125; &#125; &#125;&#125; 可以看出，继承Behavior的System可以很方便地使用自带的各种回调函数（如Awake），业务函数也变得清晰无比，只需要提供相应Component即可（如AdjustPosition）。对于一些需要复合组件的业务（如Sync），则会专门设立容器（SyncList）进行存储，对Entity的NewTickEvent与DestroyTickEvent进行监控便可筛选出合适的对象，且所有组件可通过Entity从组件容器进行获取，十分方便。 当然也不要忘记与编辑器结合的优势，System也可以将变量序列化与编辑器交互： 当然Unity可进行序列化的部分只有实例变量，所以需要作此处理： 12345678910111213public class Test : MonoBehaviour &#123; private static Test Instance; public static int Get() &#123; return Instance.value; &#125; public int value; protected void Awake() &#123; Food.Instance = this; &#125;&#125; 因为System是单例Behavior，所以这么做是安全的。如此便可操作实例对象了。 后记 总的而言，ECS框架主要是一种对OOP思想的反思，甚至可以说是一种复古（函数式编程风格）。也是一种彻底的组件模式实现，彻底地奉行数据-逻辑分离。它使得我们更容易地去抽象、描述游戏事物。当然我认为它在某种程度上是反直觉的、抽象的（某些只会属于某个对象所属的业务却要分开写，并且用组件去涵盖）。所以我认为它更适用于某些场景下，如动作游戏里的地图单位，分为多种样式（物件、道具、战斗单位、NPC、飞行道具等），这种时候使用传统的继承+子对象写法确实不如ECS来得好了。再比如UI方面，我认为还是MVC框架更为王道。所以切忌教条主义，一切跟着实际需求走。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《Brick & Ball》开发总结（三）——游戏性]]></title>
      <url>%2F2018%2F03%2F12%2Fbnb_3%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 总算到了最后一篇了，这篇我想写一些关于本游戏在画面表现与游戏性方面的总结，毕竟游戏项目的重点不仅在于程序，还在于策划与美术。 《Brick &amp; Ball》（下称BNB）从游戏元素来看其实就是乒乓球与打砖块的结合，但其实创作灵感是源自《Table football》，这是一种实体游戏，当时我玩了之后便爱不释手，起了将其搬上手机的想法（实际上已有人这么做了）。但因其操作的复杂度对于手机而言过高遂进行了精简，便有了现在的BNB。 画面表现界面风格 界面的美术风格选择的是类似《Persona5》的黑白风格，这种风格可以明显地与场景区别出来。个人认为界面与场景的分隔是很重要的，这样方能轻松识别两者。 Tween运动 Tween运动出自tween.js，意为包含多种样式的插值运动。由此可实现多种曲线的运动效果，在本项目使用的库为DOTween。 Tween运动在游戏的运用可谓方方面面，如LOGO与按钮的弹出、镜头的运动、计分板的变化等等。它使得运动的表现更为柔和与多变，而不是朴素的线性运动。 打击感 作为存在碰撞交互的游戏，打击感的表现自然是重中之重。在搭载物理引擎的基础上，还表现为在高速下球会产生扭曲现象（如下图所示）以及产生碰撞后会出现特效、音效以及物体抖动、镜头抖动和手机震动的效果。 战时无界面 鉴于游戏性质的原因，游戏进行时并不适合存在界面显示，而事实上存在着计分以及冷却提示的需求。于是利用了两边的墙壁作为计分板，利用砖头的颜色变化作为冷却进度以及冷却完毕的提示。 游戏性渐进的节奏 由于本游戏的核心玩法实际上是较为单调单一的，所以必须严格控制游戏时长，不能陷入长期的拉扯战。所以必须加入逐渐让游戏加速的设定，具体表现为背景音乐的速度以及球的速度。当加速到一定程度便能穿透砖头，所以不会出现理论上的无限期游戏，达到了控制游戏时长的目的。 速度控制 球的速度与游戏体验息息相关，所以对此作了严格的控制。球的初始速度来自发射，碰到砖块时会保留一定比例的当前速度并追加速度。所以理论上是会越来越快的，但速度累积到一定程度后便会陷入暴走，所以在保留比例上会采用反比例函数使得高速下的保留比例更低，而反之低速下的保留更多，从而达到更健康的游戏体验。另外撞到墙壁或拉伸下的砖块都会有速度加成。 场景变化 随着游戏进度会使得场景产生变化，从而影响游戏性是一种不错的做法。BNB在这方面的体现则是计分板的变化，因为计分板的也是作为实体而存在的，球撞到计分板的边角会产生不一样的运动反应，以及撞到计分板上会获得更大的加速。通过这点使得游戏得到了更为渐进的体验，从而提高游戏性。 后记 第三篇的内容显然比之一二少了很多，毕竟小游戏就是小游戏，在游戏内容上注定单一，但也可以看出蕴含不少讲究的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《Brick & Ball》开发总结（二）——服务端]]></title>
      <url>%2F2018%2F03%2F11%2Fbnb_2%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 书接上文，这次要讲的是服务端。《Brick &amp; Ball》（下称BNB）所需要的网络功能仅为匹配与联机对战而已，所以在最初对此是轻视的，在尝试了UNet与Photon之后感觉各有硬伤（UNet不支持纯服务端架设、Photon服务端为Windows），遂放弃了这些看似完备的服务端套件，转为使用小有名气的Skynet后，不负所望地顺利完成了，于此做个总结。 结构 在阅读本文之前，你需对Skynet有个大致的了解。Skynet的业务单位称为服务，它是一种Actor模型的实现。以下是BNB服务端的服务结构： Gate: 网关服务，负责管理用户（接入、踢出、发信、心跳包）。 Queue: 队列服务，负责用户的匹配，当有新的用户到来就会进入队列。 Lobby: 大厅服务，负责Room的管理（创建、关闭），完成匹配的用户就会为他们创建Room。 Room: 房间服务，负责用户的游戏提供（帧锁定同步）。 KCP 对于BNB这种高实时性的游戏，自然是不方便使用TCP了（三次握手、非快速重传、滑动窗口），然而直接使用UDP又会有可靠性的问题（丢包、非顺序到达），业界流行的做法一般是在UDP的基础上实现重传保证可靠性，而其中比较著名的实现则是KCP（再次感谢Skywind！）。KCP虽然是用C语言实现的，但还是有C#和Lua的移植与封装的版本。 封包 在封包的设计上我图省事使用了JSON，并在封包的首部使用了1字节作为标志，并未考虑加密（因为觉得没有意义）。C#方面直接使用内置函数解决，Lua则是使用了CJSON，字节处理则是使用Lua5.3新增的string.pack与string.unpack函数（非5.3需安装struct）。 接入用户 按理来说客户端与服务端的初次连接使用TCP更为适合（一个KCP对象只服务一个连接，所以初次连接的客户端在服务端并没有对应的KCP对象），但是为了偷懒我采用了这样的方式：12345678910111213-- Check ID of packet is ID.connectif (not _agentMap[from] and string.unpack("b", data, #data) == _ID.connect) then local addr = _SOCKET.ToAddress(from) _SKYNET.Log("connect", addr) _agentMap[from] = _Agent.New(1, from, function (_data) _SOCKET.sendto(_udp, from, _data) end) _clientCount = _clientCount + 1 _agentMap[from]:Send(_ID.connect, &#123;addr = addr, version = _version, isFull = _clientCount &gt; _maxClient&#125;)elseif (_agentMap[from]) then _agentMap[from]:Input(data)end 对于不在用户列表的来源，则直接判定该包尾部1字节是否等于_ID.connect（KCP会在封包的头部添加信息，所以在没有JSON内容的情况下，该包尾部则是原封包的头部），这种野蛮的方式缺点自然是只能填写标识而不能添加JSON。所以如果客户端还需要一些信息的话还需要收到回执后补充，当然事实上就需要回执：存在着因版本不对、服务器爆满的情况而拒绝连接的情况。所以服务端需要回执后方正式将其接入。 心跳包 鉴于UDP的无连接特性，是无法判断用户是否掉线的（事实上TCP的机制也非完美）。业界通行的做法是做心跳包，即每隔一段时间进行通信以确定对方仍存活。BNB采用的方式是礼尚往来（客户端每隔一段时间发送心跳包，服务端收到后发送回执），即双端皆有心跳状态：在客户端看来，无论是超时没有收到心跳包、亦或是自身无法发出心跳包，都视为掉线。在服务端看来，只要该客户端超时没有发过心跳包，即踢出之： 12345678910-- Serverfunction _FUNC.Heartbeat() for k, v in pairs(_agentMap) do if (not v.heartbeat) then _FUNC.Kick(k) else v.heartbeat = false end endend 1234567891011// Clientprivate void HeartbeatTick() &#123; if (!this.heartbeat) &#123; this.Disconnect(); &#125; else &#123; this.Send(EventCode.Heartbeat); this.heartbeat = false; this.heartbeatTimer.Enter(HEARTBEAT_INTERVAL, this.HeartbeatTick); &#125;&#125; 匹配队列 BNB的匹配规则就是没有规则，匹配到了两名玩家就开始游戏，所以只需设计一个队列即可。每逢有新用户接入后便会进入队列，如用户离去则从队列消除，若匹配成功则为他们创建一场游戏： 123456789101112131415161718function _CMD.OnHandshake(id, fd) if (not _SKYNET.Call(_gate, "CheckAgent", fd)) then return end if (not _readyFd) then _readyFd = fd else _SKYNET.Send(_lobby, "NewRoom", _readyFd, fd) _readyFd = nil endendfunction _CMD.OnDisconnect(id, fd) if (_readyFd == fd) then _readyFd = nil endend 创建游戏 在匹配完成后，便会由Lobby服务为一对用户创建房间（Room服务），在此之前会对两名用户是否在线进行检查，若不满足则将两名用户进行踢出，需重新进行连接： 1234567891011121314151617function _CMD.NewRoom(leftFd, rightFd) local fds = &#123;leftFd, rightFd&#125; if (not _SKYNET.Call(_gate, "CheckAgent", fds)) then _SKYNET.Send(_gate, "Kick", fds) return end local deviceModels = _SKYNET.Call(_gate, "GetAgentValue", fds, "deviceModel") _leftFdMap[leftFd] = rightFd _rightFdMap[rightFd] = leftFd _roomMap[leftFd .. rightFd] = _SKYNET.newservice("room") _SKYNET.Send(_roomMap[leftFd .. rightFd], "Start", leftFd, rightFd, deviceModels[1], deviceModels[2]) _SKYNET.Log("start room", _SOCKET.ToAddress(leftFd), _SOCKET.ToAddress(rightFd))end 创建房间之后，会为对应的客户端发送开始游戏所需的数据（随机数种子、双方阵营所属）。待客户端初始化完毕后，游戏正式开始： 1234567-- Serverfunction _CMD.Start(leftFd, rightFd, leftDevice, rightDevice) _fds = &#123;leftFd, rightFd&#125; _deviceMap[leftFd] = leftDevice _deviceMap[rightFd] = rightDevice _FUNC.Send(_ID.start, &#123;seed = os.time(), leftAddr = _SOCKET.ToAddress(leftFd), rightAddr = _SOCKET.ToAddress(rightFd)&#125;)end 123456789101112131415161718// Clientprivate void OnStart(byte id, string data) &#123; var obj = JsonUtility.FromJson&lt;Datas.Start&gt;(data); Random.InitState(obj.seed); Judge.PlayerType = this.addr == obj.leftAddr ? PlayerType.A : PlayerType.B; Judge.SetAddr(obj.leftAddr, obj.rightAddr); this.startGameSlot.Run(this.gameObject); this.online = true; this.updateTimer = 0; this.frame = 0; this.playFrame = 0; this.exitCode = ExitCode.None; this.sendInLoop = false; this.playDataList.Clear(); this.playDataList.Add(new PlayData()); Networkmgr.MovingValue = 0; Networkmgr.WillElaste = false;&#125; 帧锁定同步 如上文所言（在采用传统帧锁定同步的基础上，服务端设定等待时长，超时则继续），服务端的业务设计成当接收到一名用户的输入包后，就会开始进行计时（9毫秒，约等于客户端的5帧，即WAITTING_INTERVAL）。若超时或在时间内抵达第二名用户的输入包，则进行结算（广播用户们的输入数据）。用户的输入数据在服务端是作为缓存式的，超时了也会进行记录，作为下一次结算所用，每次结算后输入数据则会清空： 1234567891011121314151617181920212223242526272829303132333435function _CMD.ReceiveInput(fd, obj) _inputMap[fd] = obj.data -- Must be current frame, otherwise only save input data. if (obj.frame == _playFrame) then if (not _readyPlay) then _readyPlay = true local time = _playInterval - (_SKYNET.now() - _timer) time = time &lt; 0 and 0 or time _SKYNET.timeout(time, _FUNC.Play) -- Server will run _FUNC.Play after the time goes on. else _FUNC.Play() end endendfunction _FUNC.Play() if (not _readyPlay) then return end _TABLE.Clear(_playSender.addrs) _TABLE.Clear(_playSender.inputs) for k, v in pairs(_inputMap) do table.insert(_playSender.addrs, _SOCKET.ToAddress(k)) table.insert(_playSender.inputs, v) end _FUNC.Send(_ID.input, _playSender) _TABLE.Clear(_inputMap) _readyPlay = false _timer = _SKYNET.now() _playFrame = _playFrame + 1end 维护 服务端不同于客户端，发生错误使程序崩溃的代价是很大的，所以有必要建立完善的应对措施。所幸目前发现Skynet发生错误时会影响的仅为Skynet.fork的函数（发生错误后函数会停止运行），并不会导致整个服务崩溃乃至进程崩溃。于是只要利用Lua的pcall(func, ...)函数进行异常处理即可： 12345678910111213141516function _SKYNET.Loop(Func, sleepTime) local LoopFunc = function() while true do local ret, text = pcall(Func) if (not ret) then _SKYNET.Log(text) _SKYNET.Warn() end _ORIGIN_SKYNET.sleep(sleepTime) end end _ORIGIN_SKYNET.fork(LoopFunc)end 当然遇到问题仅仅是堵住那只是治标不治本，所以我采用了邮件报警机制。只要在config文件填写mail，然后调用_SKYNET.Warn()即会发送到目标邮箱，且整个进程生命周期内只会发送一次，避免疯狂轰炸的情况： 123456function _SKYNET.Warn() if (_mail and not _DATA_CENTER.get("hasWarn")) then os.execute(string.format("shell/warn.sh %s '%s'", _mail, _logger)) _DATA_CENTER.set("hasWarn", true) endend 虽然理论上没有会令Skynet进程崩溃的情况，但以防万一，还是专门做了崩溃重启的措施： 12345678910111213141516basepath=$(cd `dirname $0`; cd ..; pwd)cd $basepathwhile truedo count=`ps -ef | grep skynet | grep -v "grep" | wc -l` if [ $count -gt 0 ]; then : else echo "program has crashed, restarting..." screen shell/run.sh fi sleep 10done 还有一点就是，帧锁定同步的浮点数问题并不是那么令人放心的存在。所以有必要对其进行监控（这个在上文也有提到），同理遇到异常情况也会进行邮件报警： 12345678910111213141516171819202122232425function _CMD.ReceiveComparison(fd, obj) if (not _comparsionHandler[obj.playFrame]) then _comparsionHandler[obj.playFrame] = &#123;&#125; end local map = _comparsionHandler[obj.playFrame] map[fd] = obj.content if (_TABLE.Count(map) == _playerCount) then local lk, lv for k, v in pairs(map) do if (lv and v ~= lv) then -- Output current frame, each device name and comparsion data. _SKYNET.Log(obj.playFrame, _deviceMap[k], v, "!=", _deviceMap[lk], lv) _SKYNET.Warn() end lk = k lv = v end _comparsionHandler[obj.playFrame] = nil endend 后记 这次是本人初次进行服务端开发，如有不妥之处但请指教。虽无涉及数据库、反作弊、集群、运维等方面，但也不失为一个匹配-房间-帧锁定同步的好范例。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一次移植代码时关于For循环的发现]]></title>
      <url>%2F2018%2F03%2F11%2Ffor_loop%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 今日使用Python移植一份C++实现的算法发生了效果不一致的问题，经过仔细分析后发现问题竟出自For循环，由此引申此文。 详情 首先来看看C++的For循环： 12345int i = 0;for (i = 0; i &lt; 5; i++) &#123; //do something&#125; 然后再来看看根据直觉进行移植的Python代码： 1234i = 0for i in range(0, 5): # do something 咋看之下似乎并没有问题，但若是在循环结束后输出i值，其结果竟是不一致的（C++为5，而Python为4）！在大多数情况下，C++的循环变量并不会在外部定义，所以其生存域仅在For循环之中，这种情况下并不会有什么问题。然而一旦如此，便代表i肯定要用于后续了，如此结果相差1便可让整个程序炸掉。 仔细想来C++和Python的循环实现本就不一致，C++是使用一个逻辑值和两个表达式展开的，而Python则是一个生成器，且Python的生存域向来独树一帜，结果不一致也是理所当然的。可是在凭直觉或未了解过的情况下进行移植时便很容易中招，这便是本文的意义，以示警戒。 其他语言的For循环 俗话说举一反三，遇到这种问题自然会想到其他编程语言关于For循环的细节，我便选择了我日常使用的Lua和C#做了尝试： 12345local n = 1for n=1, 5 do --do somethingend 12345int i = 0;for (i = 0; i &lt; 5; i++) &#123; //do something&#125; Lua循环完毕后n的值为1，可谓相当遵守生存域了（循环是一个域，与外部变量无关）。而C#则是与C++一致，这也是理所当然的，毕竟以上代码跟C++长得完全一致嘛（估计Java也是如此）。 后记 仔细想来编程语言之间的循环代码虽然看起来相似，但实际上他们的具体实现乃至表达式都是有所不同的，可见不可想当然，否则就容易遭遇今日这样的问题了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《Brick & Ball》开发总结（一）——帧锁定同步]]></title>
      <url>%2F2018%2F03%2F09%2Fbnb_1%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 辗转反侧三个月，《Brick &amp; Ball》（下称BNB）的开发工作总算告一段落了，游戏也顺利地在TapTap上架以及在Github开源了。接下来将会对帧锁定同步、服务端、游戏性三方面进行开发的总结，预计会用三篇完成，敬请关注。 由TapTap上的介绍可知，BNB是拥有联机对战模式的，而联机对战的重点自然在于同步，本文便对同步的实现的相关问题做个总结。 实现思路 在阅读此文之前，你需要对帧锁定同步有个大致的了解，关注我的博客应该知道在去年我已经对此做了个初步的探究。从现在来看当时的实现还不够好，于是很有必要重新梳理一遍。 若是有尝试过实现帧锁定同步的朋友相信对于传统的帧锁定同步（Lockstep，所有玩家的延迟都是延迟最差的那位）实现还好说，但对于“乐观帧锁定（不会等待延迟高的玩家）”的实现，则是各说纷纭。除了上文所说的那种方式（服务端主动每隔一段时间广播，客户端输入数据随时上传），还有一种《Warcraft III》的实现（在采用传统帧锁定同步的基础上，服务端设定等待时长，超时则继续），个人认为这种实现更为靠谱，也通过这次实践证明了其可行性。 帧锁定 顾名思义，帧锁定同步分为帧锁定与同步两大部分。所谓帧锁定，个人认为便是将Update部分严格管控起来，以此修正了玩家之间帧率不一致的问题以及收到多个输入包时的快进处理。接下来看看其具体实现： 12345678910111213141516171819202122protected void Update() &#123; this.updateTimer += Mathf.CeilToInt(Time.deltaTime * 1000); //DT = 17 while (this.updateTimer &gt;= DT) &#123; this.client.Update(); //Receive packet if (this.playDataList.Count &gt; 1) &#123; var lateFrame = this.frame; this.sendInLoop = true; do &#123; this.client.Update(); //Receive packet this.LockUpdate(true); &#125; while(this.playDataList.Count == 1 &amp;&amp; this.frame == lateFrame); //Go to latest process &#125; this.LockUpdate(); this.updateTimer -= DT; &#125;&#125; 帧锁定的核心便在于此，在每次Update进行时间累积，只有累积到了额度（DT）后会进行真正的更新（LockUpdate），且每次更新后会扣除额度，以求最精确，这里对计时进行毫秒化也是为此。这种手段在Unity被称为FixedUpdate，当然我们的需求不仅于此，因此并没有使用它。 除此之外，便是收到多个输入包进行快进的处理了。这里的this.frame代表当前进度下的帧号，每当进入下一个进度后便会清0。于是我们只要快进到最新进度下的当前帧即可，随后再进行一次正常的LockUpdate。当然不要忘记快进时也有必要进行接收数据包，因为在快进时仍可能有后续输入包的到来。 LockUpdate 接下来便来看看LockUpdate的具体实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void LockUpdate(bool inLoop=false) &#123; //WAITTING_INTERVAL = 5 if (this.online &amp;&amp; this.frame + 1 == WAITTING_INTERVAL &amp;&amp; this.playDataList.Count == 0) &#123; return; &#125; if (this.online) &#123; this.frame++; if (this.frame == WAITTING_INTERVAL) &#123; var data = this.playDataList[0]; this.playDataList.RemoveAt(0); if (Judge.IsRunning &amp;&amp; data.addrs != null) &#123; //Apply later input for (int i = 0; i &lt; data.addrs.Length; i++) &#123; Judge.Input(data.addrs[i], data.inputs[i]); &#125; &#125; this.playFrame++; this.frame = 0; if (!inLoop || (inLoop &amp;&amp; this.sendInLoop)) &#123; //Send now input var input = new Datas.Input() &#123; data = new InputData() &#123; movingValue = Networkmgr.MovingValue, willElaste = Networkmgr.WillElaste &#125;, frame = this.playFrame &#125;; this.sendInLoop = false; Networkmgr.WillElaste = false; this.client.Send(EventCode.Input, input); &#125; //Send comparison data var comparison = new Datas.Comparison() &#123; playFrame = this.playFrame, content = Judge.Comparison &#125;; this.client.Send(EventCode.Comparison, comparison); &#125; &#125; //Game world update Networkmgr.UpdateEvent(); Networkmgr.LateUpdateEvent();&#125; LockUpdate主要做的事情为每隔一定帧数（WAITTING_INTERVAL）上传当前的操作输入，以及应用上次的操作输入（来自服务端），如果到了关键帧时上次的操作输入包仍未抵达，则会陷入等待。也就是说，帧锁定同步其实就是一种每隔几帧的回合制而已。具体的流程图可参考Skywind的提供：  当然这里还有个细节要注意：在处于快进的时候，上传输入只会在初次进行，因为在快进下实际上能响应到玩家的操作其实一开始就定下了，后续进行的上传也只会是相同的，所以没有意义。 LockBehaviour 由LockUpdate可知两行代码Networkmgr.UpdateEvent();和Networkmgr.LateUpdateEvent();，它们是两个event，负责绑定执行整个游戏涉及到帧锁定的Update，毕竟Unity并不存在主宰一切的主Update，所以只好用这种方式实现。为此专门涉及了LockBehaviour： 1234567891011121314151617181920212223242526272829303132333435public class LockBehaviour : MonoBehaviour &#123; public enum OrderType &#123; Normal, Late &#125; [SerializeField] protected OrderType orderType = OrderType.Normal; protected void Awake() &#123; if (this.orderType == OrderType.Normal) &#123; Networkmgr.UpdateEvent += this.LockUpdateWrap; &#125; else &#123; Networkmgr.LateUpdateEvent += this.LockUpdateWrap; &#125; &#125; protected void OnDestroy() &#123; if (this.orderType == OrderType.Normal) &#123; Networkmgr.UpdateEvent -= this.LockUpdateWrap; &#125; else &#123; Networkmgr.LateUpdateEvent -= this.LockUpdateWrap; &#125; &#125; private void LockUpdateWrap() &#123; if (this.isActiveAndEnabled) &#123; this.LockUpdate(); &#125; &#125; protected virtual void LockUpdate() &#123;&#125;&#125; LockBehaviour继承于MonoBehaviour，且设立了LockUpdate函数，启动后便会对UpdateEvent进行注册，同理销毁后便会去除。如此一来涉及到帧同步的组件只要继承LockBehaviour并将业务写在LockUpdate便可。当然由此可以看出，Unity官方实现的组件并不吃这套，所以为此我专门引入了一款第三方物理引擎——Jitter。 同步优化 由于BNB的操作方式并非点击鼠标、按下键盘这种间歇性操作，而是最为不适合用于联机的拖动。所以在正常情况下的表现效果很差（每隔5帧瞬移一下，形成顿顿的感觉），于是PVP模式下采取了与PVE不同的拖动表现：赋予拖动表现为流畅变速的运动，当然在那短短的时间里是不可能做出流畅的运动表现的，所以选择运动的时间基准其实更长（0.25秒）。当收到新的输入时便会直接完成运动（直接到目的坐标）且继续新的运动。使用这种方式达到了相对不错的效果，当然代价便是砖块的运动相应并非实时性的，变相增加了操作难度。这也是无奈之举，好在这实际上是公平的（双方皆如此）。 除此之外便是为向上拖动做了缓存处理，只要你曾进行了此行为，便会标记你做了该行为，在下一个进度时生效。这样比之到了关键帧时才响应操作要好多了，增加了操作的命中率。 浮点数处理 帧锁定同步的一大心病便是不同设备下浮点数的处理结果不一致导致的不同步，著名的解决方案有定点数和尾数截断。而BNB采用的方式为尾数截断，其实现方式为： 1234567public static float ToFixed(this float value) &#123; return Mathf.Floor(Mathf.Abs(value * 1000)) * 0.001f * value.ToDirection();&#125;public static int ToDirection(this float value) &#123; return value &gt;= 0 ? 1 : -1;&#125; 这种尾数截断的方式便是主动限制小数点范围，以减少精度的方式阻止错误的发生。如此运用在各种涉及到同步方面的浮点数进行处理即可。而在这方面最大的敌人便是物理引擎了，众所周知物理引擎拥有自己的生态环境，牵涉内容甚多，经过一番艰苦尝试后最终选择了放弃修改其内核，而是改为自己实现物理运动。毕竟物理引擎的两大组成为运动和判定，如此只使用其判定即可。 当然这浮点数的处理总体而言仍是涉及甚广，所以需要进行专门的监控调试。LockUpdate里的comparison即是为此，其涉及属性Judge.Comparison内容为： 123456789101112131415161718192021222324public static string Comparison &#123; get &#123; var sb = new StringBuilder(); var pos = Ball.Position; var vel = Ball.Velocity; sb.Append(pos.x + ","); sb.Append(pos.y + ","); sb.Append(pos.z + ","); sb.Append(vel.x + ","); sb.Append(vel.y + ","); sb.Append(vel.z + ","); sb.Append(INSTANCE.teamA.brick.transform.localScale.x + ","); sb.Append(INSTANCE.teamA.brick.transform.position.x + ","); sb.Append(INSTANCE.teamA.brick.transform.position.z + ","); sb.Append(INSTANCE.teamB.brick.transform.localScale.x + ","); sb.Append(INSTANCE.teamB.brick.transform.position.x + ","); sb.Append(INSTANCE.teamB.brick.transform.position.z + ","); sb.Append(INSTANCE.teamA.wall.transform.position.z + ","); sb.Append(INSTANCE.teamB.wall.transform.position.z + ","); return sb.ToString(); &#125;&#125; 是的，很粗暴的处理方式，将游戏影响同步的相关数据进行文本化，在每个关键帧都将其上传令服务器进行匹配，当然也可以选择做成MD5码，当然这样便无法知晓具体哪个部分出了问题，故直接上传。 后记 总体来说帧锁定同步涉及的内容还是挺多的，另外还有诸如防作弊之类的问题没有探讨，因为我认为BNB没有做反作弊的必要（小游戏）。具体许多细节还是要亲力亲为去实践一遍方可出真知。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C#之弱事件（Weak Event）的实现]]></title>
      <url>%2F2018%2F02%2F18%2Fweak_event_csharp%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 最近使用C#开发项目时，发现一个会导致内存泄漏的陷阱——event里的成员并非弱引用，这样便会导致与event相关联的对象都不会被回收，从而导致内存泄漏。如此便很有必要实现一款弱事件（Weak Event）以解决此问题。 分析 首先当然是找找是否存在现成的方案，答案是有的，不过很奇怪的是，该解决方案隶属于WPF，那么便没戏了。从网上来看也有不少各自的实现，不过个人对此都不算太满意，于是便打算自己造个轮子。 实现弱事件自然需要用到弱引用，而弱引用的具体实现则是WeakReference，可以根据Delegate提供的Target作为弱引用对象，Method作为调用。 剩下的问题便是Delegate的参数问题了，很可惜Delegate似乎不支持作为泛型，但是Delegate的参数还是支持的。但即便是支持，也不方便作为多个参数来进行了。那么只能选择继承EventArgs了，EventArgs本身是个空类，一般做法是继承它然后自定义，这也是微软官方所推荐的做法。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071using System;using System.Reflection;using System.Collections.Generic;public class WeakEvent&lt;TEventArgs&gt; where TEventArgs : EventArgs &#123; public delegate void Func(TEventArgs e); private static object[] ARGS = new object[1]; private class Unit &#123; private WeakReference reference; private MethodInfo method; private bool isStatic; public bool IsDead &#123; get &#123; return !this.isStatic &amp;&amp; !this.reference.IsAlive; &#125; &#125; public Unit(Func callback) &#123; this.isStatic = callback.Target == null; this.reference = new WeakReference(callback.Target); this.method = callback.Method; &#125; public bool Equals(Func callback) &#123; return this.reference.Target == callback.Target &amp;&amp; this.method == callback.Method; &#125; public void Invoke(object[] args) &#123; this.method.Invoke(this.reference.Target, args); &#125; &#125; private List&lt;Unit&gt; list = new List&lt;Unit&gt;(); public int Count &#123; get &#123; return this.list.Count; &#125; &#125; public void Add(Func callback) &#123; this.list.Add(new Unit(callback)); &#125; public void Remove(Func callback) &#123; for (int i = this.list.Count - 1; i &gt; -1; i--) &#123; if (this.list[i].Equals(callback)) &#123; this.list.RemoveAt(i); &#125; &#125; &#125; public void Invoke(TEventArgs args=null) &#123; ARGS[0] = args; for (int i = this.list.Count - 1; i &gt; -1; i--) &#123; if (this.list[i].IsDead) &#123; this.list.RemoveAt(i); &#125; else &#123; this.list[i].Invoke(ARGS); &#125; &#125; &#125; public void Clear() &#123; this.list.Clear(); &#125;&#125; 以上便是弱事件的实现代码了，其实原理与Caller基本一致。接下来是演示： 1234567891011121314151617181920212223242526272829using System;public class Obj &#123; public void Do(EventArgs e) &#123; Console.WriteLine("test"); &#125; public static void StaticDo(EventArgs e) &#123; Console.WriteLine("static"); &#125; public static void Main(string[] args) &#123; var a = new Obj(); var b = new Obj(); var weakEvent = new WeakEvent&lt;EventArgs&gt;(); weakEvent.Add(a.Do); weakEvent.Add(b.Do); weakEvent.Add(StaticDo); weakEvent.Add((EventArgs e) =&gt; Console.WriteLine("lambda")); a = null; weakEvent.Remove(StaticDo); GC.Collect(); weakEvent.Invoke(); Console.WriteLine(weakEvent.Count); &#125;&#125; 输出结果为： 123lambdatest2 以上分别演示了静态方法、实例方法、匿名方法，其中静态方法和匿名方法需要手动调用Remove将之移除，如演示一般那样匿名方法便无从回收了，这点需要注意。如此弱事件便完成了，当然它带来了一定的性能损耗，这是无可避免的。也并未经过长久实践的磨砺，可以说只是一个原型罢了。 后记 类似这样的内存泄漏问题在开发过程中可有不少，尤其是有了GC的庇护下对此更为麻痹。一般需要定期使用专业工具进行检测，这也是优化的一环啊。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《DNFMobile》图片资源提取笔记]]></title>
      <url>%2F2018%2F01%2F20%2Fdnf_mobile_ex%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 《DNFMobile》的新一波内测到来了，恰好得到了安装包。便欲对比其资源较之端游有何不同，遂试图提取之。在尝试的途中遇到了不少问题，特此记录之。源码地址 读取资源包 与众多手游的习惯一样，初始的安装包所携带的资源甚少，皆需经过更新方才完整。更新后经过观察得知游戏采用Unity制作，那么事情便简单了，直接上UnityStudio读取。虽然资源文件的后缀名为.npk，但实际上则是Unity的AssetBundle，且并未作加密。然而诸多现成的Unity提取工具皆有多少缺陷（无法识别pvr格式、无法批量化操作、导出资源过于原始等），且图片资源是大图形式存在的，需要进行切图，而使用切图工具一则怕不够精确，二则怕无法批量化。于是我选择直接使用Unity制作工具以面对此需求。 由于资源文件本身即是Unity的格式，那么直接调用API加载即可，类似如此： 123456var assetBundle = AssetBundle.LoadFromFile(path);var assetBundle.LoadAllAssets&lt;Texture2D&gt;();foreach (var tex in texs) &#123; //...&#125; 切图 这样可谓相当方便，接下来的问题便是切图了。我本以为大图是由Unity自动生成，所以理应资源内会有对应的Sprite资源，这样通过Sprite资源的信息即可进行切割。但实际上并非如此：大图是事先生成好，然后使用脚本填写每帧配置在运行时自动生成Sprite。这种做法也是理所当然的，毕竟Unity的Sprite的pivot与DNF的IMG包提供的偏移点可谓天南地北。（一者为当前图片下的浮点百分比，另一者为实际坐标）通过直接在配置直接对接IMG包的数据然后进行转化这是很正常的做法。可这下子就麻烦了，我们并无法直接知道这脚本的具体信息。幸好UnityStudio的解析中包括了关于MonoBehavior资源配置的信息。 可即使知道也无法直接Unity进行获取，毕竟我们本身是没有该脚本的。鉴于UnityStudio开源的特性，我起初打算阅读源码掌握其解析之法。最后也成功了，可我突然脑内灵光一闪，想到了直接建立一个同名脚本，并根据配置的信息进行模拟。代码如下： 1234567891011121314151617181920212223242526272829303132333435using System;using System.Collections;using System.Collections.Generic;using UnityEngine;public class DNFAtlasAsset : MonoBehaviour &#123; [Serializable] public struct Rectf &#123; public float x; public float y; public float width; public float height; &#125; [Serializable] public struct DNFAtlasElement &#123; public string name; public int originIndex; public int referenceIndex; public int originWidth; public int originHeight; public int offsetX; public int offsetY; public Rectf rect; &#125; [Serializable] public struct DNFAtlasSlot &#123; public int matType; public DNFAtlasElement[] elementList; &#125; public string atalsName; public DNFAtlasSlot[] atlasSlotList;&#125; 天可怜见，居然成功了！那么接下来采用类似如下方法即可： 123456789101112131415161718192021int width = (int)element.rect.width;int height = (int)element.rect.height;if (width == 0 || height == 0) &#123; continue;&#125;var colors = tex.GetPixels((int)element.rect.x, (int)element.rect.y, width, height);var newTex = new Texture2D(width, height, tex.format, tex.mipmapCount &gt; 1);newTex.SetPixels(colors);newTex.Apply();var path = this.GetPath() + tex.name + "/";var bytes = newTex.EncodeToPNG();var json = JsonUtility.ToJson(element);var name = this.ToNumber(element.name);this.CreateDirectory(path);File.WriteAllText(path + name + ".json", json);File.WriteAllBytes(path + name + ".png", bytes);Texture2D.DestroyImmediate(newTex, true); 主要思路便是通过GetPixels方法读取区域像素并覆盖至新图。最后将图片转换为PNG、配置转换为JSON并输出即可。 当然这里还有关于Texture2D的readable问题，隶属于资源包的Texture2D并无法直接使用GetPixels方法，需要对其进行复制，然后利用新图施为，为此我写了个函数： 1234567891011121314151617181920private Texture2D GetTexture(Texture2D tex)&#123; if (!this.texureMap.ContainsKey(tex)) &#123; if (tex.width == 0 || tex.height == 0) &#123; return null; &#125; var copyTex = new Texture2D(tex.width, tex.height, tex.format, tex.mipmapCount &gt; 1); copyTex.LoadRawTextureData(tex.GetRawTextureData()); copyTex.Apply(); var writeTex = new Texture2D(copyTex.width, copyTex.height); writeTex.SetPixels32(copyTex.GetPixels32()); writeTex.Apply(); writeTex.name = this.ToName(tex.name); this.texureMap[tex] = writeTex; Texture2D.DestroyImmediate(copyTex, true); &#125; return this.texureMap[tex];&#125; 以上便是关于切图方面的问题，具体可参阅源码。 内存问题 游戏目前的资源包数量高达2900以上，在尝试一口气全部提取时内存竟然高达5G！最终电脑不堪重负倒下收场。这很显然是资源并未回收所致，是以作此函数： 12345678910public void Destroy() &#123; foreach (var texture in this.texureMap) &#123; Texture2D.DestroyImmediate(texture.Key, true); Texture2D.DestroyImmediate(texture.Value, true); &#125; this.texureMap.Clear(); this.assetBundle.Unload(true); AssetBundle.DestroyImmediate(this.assetBundle, true);&#125; 这里采用的是DestroyImmediate方法，好处是立即进行回收，但却会因此阻塞，影响提取效率。若使用Destroy方法则不会如此，不过峰值内存会上升。但大规模读取时还是以稳定为主，而小份读取则两者并无所谓。是以选择DestroyImmediate方法。 另外在其他地方涉及到资源生成且是继承自UnityEngine.Object的，皆需注意此问题。在经过优化后，占用由5G跌倒了500M-1.5G之间，成功提取了全部图片资源。大功告成！ 后记 这次《DNFMobile》的声音资源经过了高压，原本几M的音乐变成了上百K，可谓惨不忍听，遂无提取的价值。而纸娃娃方面则是采用了类似NPK_Ver4的色板做法，也并无法直接提取到成品。由此可见制作组为了节省空间可是下了不少功夫呀。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017年度总结]]></title>
      <url>%2F2017%2F12%2F31%2Fsummary_2017%2F</url>
      <content type="text"><![CDATA[时境过迁，不知不觉一年又要过去了。不禁感慨，特此总结下今年的经历与收获，以作归纳。 要说今年最以往不同的那便是开通了个人的bolg，从2月26日开始共写了13篇，可谓差不多是月均一篇了。写博文最大的好处便是可以记录问题、归纳知识，乃至传播分享。感觉还是很不错的，目测接下来仍会继续。 学业方面由于上了本科，开始有机会去补充理论知识的空缺了。在《数据结构》和《操作系统》课程上得到了不少收获。并且还会抽空阅读《C++ Primer》和《计算机网络》，虽不算学有所成，但也算开阔眼界。 出于积累算法底蕴及应付面试，今年开始刷起了LeetCode，不过要说刷其实也不对，毕竟只是一日一题而已。只能说是当成益智游戏了。 项目方面，出于《Lavivagnar》和《Brick&amp;Ball》的缘故，对于Unity的掌握可谓正式上了轨道，果然最佳的学习方式就是实践，JUST DO IT。 《DFQ》方面，总算是摆脱了去年以来的迭代旋涡，项目结构也算是稳定下来了，开发正在有条不絮的进行中，目前对于资源管理方面积累了不少经验，来年分享。 《GreatFighter》因为忙碌的关系，算是停工了，可惜无法见识到Manistein的大展施为，以及少了个实践C++的机会。不过时间就这么多，勉强不来的，还是要知足，做好能做的事情。 要说今年还有个收获的话，那便是将Python作为了生产力工具，开发了各种工具和脚本。也因此有幸参与了ChawDoe的《SOB》，对于Qt及网络编程有了不少的积累。 以上便是本人的2017年度总结，明年一月还会有《Brick&amp;Ball》的开发总结，以及开发中得出的一些经验和问题记录，敬请期待。 无双草泥马 2017.12.31]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[游戏测试同步于Android设备的解决方案]]></title>
      <url>%2F2017%2F12%2F07%2Fdfq_building%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 最近开发中的游戏需要在Android手机上进行测试，但采用USB数据线连接主机进行文件替换的更新实在是太麻烦了。遂考虑整个远程更新的解决方案，在研究的过程中排除了开发APP（耗费时长）与内置热更新（LuaSocket遇到点问题），最终选择了现在的在手机上安装Git客户端的方案。 详解 首先我选用了PocketGit作为Android的Git客户端，它可以满足我的基本需求。（感谢Hs的提供）但是仅仅如此是不够的，事实上不可能直接使用工程所用的Git仓库作为测试使用，毕竟测试的提交是十分频繁的。于是我首先考虑到了在工程仓库上创建测试分支，但是这也不够舒适，因为各分支的文件情况是独立的，到了特定时刻还得考虑合并的事。且测试分支的提交也会影响节点视图的观赏性，所以我选择了专门开一个测试仓库，通过编写Python脚本以一键同步相关文件并commit，十分方便。 脚本的实现 以下为程序源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import osimport timeimport shutilimport zipfiledef sync(path_a, path_b): is_file_a = os.path.isfile(path_a) is_file_b = os.path.isfile(path_b) is_dir_a = os.path.isdir(path_a) is_dir_b = os.path.isdir(path_b) if is_file_a: if is_dir_b: shutil.rmtree(path_b, True) if is_file_b: time_a = os.stat(path_a).st_mtime time_b = os.stat(path_b).st_mtime if time_a != time_b: shutil.copy2(path_a, path_b) else: shutil.copy2(path_a, path_b) elif is_dir_a: if is_file_b: os.remove(path_b) if is_dir_b: list_a = os.listdir(path_a) list_b = os.listdir(path_b) list_merger = list(set(list_a + list_b)) for path in list_merger: sync(path_a + "/" + path, path_b + "/" + path) else: shutil.copytree(path_a, path_b) else: if is_dir_b: shutil.rmtree(path_b, True) elif is_file_b: os.remove(path_b)def make_archive(path): zip_file = zipfile.ZipFile(path, "w") zip_file.write("conf.lua") zip_file.write("main.lua") zip_file.write("path.lua") for root, dirs, files in os.walk("asset/font"): for f in files: zip_file.write(root + "/" + f) zip_file.close()sync("asset", "build/asset")sync("config", "build/config")sync("source", "build/source")make_archive("build/game.love")now_time = time.strftime("%Y-%m-%d-%H:%M:%S", time.localtime(time.time()))os.system( """ cd build git add . git commit -m %s """ % now_time) 脚本的实现思路为将工程仓库下的三个文件夹与对应的测试仓库里的文件夹做对比，若工程仓库存在文件而测试仓库不存在，则复制之。若存在，则对比两者的最后修改日期，不一致则复制。（这里原本是考虑使用MD5检测文件完整性的，不过这将会影响到效率，发现在合理使用的前提下，只检测最后修改日期也无妨，遂采用）若出现测试仓库存在而工程仓库不存在的文件/文件夹，则删除之。 然后便是对某些关键文件进行打包为.love文件存放到测试仓库，它是LÖVE的可执行文件，但实际上只是个.zip文件。最后便是对测试仓库进行commit。 后记 然后如这般做好配置，便可在Android设备上克隆主机的测试仓库了（以局域网的形式）。当然还得确保主机开启了ssh，在macOS下开启ssh的方式为：System Preferences → Sharing → Remote Login。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于C语言函数strtok引发的思考]]></title>
      <url>%2F2017%2F10%2F13%2Fabout_strtok%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 近期遇到个C语言的课题作业，要求完成parse功能（以空格、回车、TAB为分割符分割字符串，输出结果且返回数组。）该功能涉及到strtok函数的一些问题，特此开贴记录。 详解 以下为程序源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;struct ListNode &#123; char * value; struct ListNode * next;&#125;;char ** parse(char * line) &#123; if (line == NULL) &#123; return NULL; &#125; static char delim[] = " \t\n"; /* SPACE or TAB or NL */ int count = 0; char * token; char ** newArgv; char str[strlen(line)]; strcpy(str, line); token = strtok(str, delim); if (token == NULL) &#123; return NULL; &#125; struct ListNode * head = (struct ListNode *)malloc(sizeof(struct ListNode)); struct ListNode * cur = head; cur-&gt;value = token; count ++; while (1) &#123; token = strtok(NULL, delim); if (token == NULL) &#123; break; &#125; cur-&gt;next = (struct ListNode *)malloc(sizeof(struct ListNode)); cur = cur-&gt;next; cur-&gt;value = token; count ++; &#125; newArgv = (char **)malloc((count + 1) * sizeof(char *)); cur = head; for (int i = 0; i &lt; count; i++) &#123; newArgv[i] = (char *)malloc(strlen(cur-&gt;value) * sizeof(char)); strcpy(newArgv[i], cur-&gt;value); printf("[%d] : %s\n", i, cur-&gt;value); free(cur); cur = cur-&gt;next; &#125; newArgv[count] = NULL; //tail return newArgv;&#125;int main() &#123; char ** argv = parse("system program"); return 0;&#125; 第一个问题 首先第一个问题便是这里： 1234char str[strlen(line)];strcpy(str, line);token = strtok(str, delim); 最初尝试直接把parse函数的参数line直接作为strtok函数的第一参数填入，结果不行。查阅文档后发现strtok的声明为： 1234//param: str -- 要被分解成一组小字符串的字符串。//param: delim -- 包含分隔符的 C 字符串。//return: 该函数返回被分解的最后一个子字符串，如果没有可检索的字符串，则返回一个空指针。char *strtok(char * str, const char * delim); 可以发现，第一参数char * str要求的并非const，而我在调用时填入的参数为‘system program’，这种字符串数据是作为‘const char[]’保存在字符串常量区的，故不符合参数需求。需要重新申请一片栈空间复制line的内容再作为参数填入。 第二个问题 由此衍生的第二个问题便是：为何要为newArgv[i]申请新的空间，而非newArgv[i] = cur-&gt;value;？ 12newArgv[i] = (char *)malloc(strlen(cur-&gt;value) * sizeof(char));strcpy(newArgv[i], cur-&gt;value); 这一点的原因主要是 strtok返回的字符串其实并非新的副本，而是从str上截取的一部分而已。 而cur-&gt;value便是来自于str，且str是拥有生命周期的栈数据，而如果将这样的部分保存在newArgv后返回到外部，便会因为生命周期问题，导致数据被回收。这将会产生很可怕的后果。所以必须申请新的空间，形成复制。 后记 没有垃圾回收的C/C++，编程时必须对内存的分配和流向必须要有十分清晰的认识，不然就很容易发生内存泄漏和野指针现象。慎之、慎之。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[帧同步的初步探究]]></title>
      <url>%2F2017%2F08%2F26%2Fframe_sync%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 在阅读这篇文章之前，你需要了解一下何为帧同步。关于帧同步的实现尝试，其实近年来一直都有不间断的尝试，不过大多浅尝辄止，这次总算是一次较为完整的实现了。接下来便对这次实现介绍一二。 详解 本次项目使用的开发引擎为LÖVE，项目地址在此。以下是运行演示（外网联机测试也通过了）： 由于我并没有什么服务端开发的相关经验，所以只是使用了个简单的UDP网络库——ENet。客户端与服务端共同处于一个项目下，非常的浅薄，以下是服务端与客户端的代码展示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172--server.lualocal Enet = require ("enet")local Lib = require("lib")local host = Enet.host_create("localhost:6789")local peerMap = &#123;&#125;local dataMap = &#123;&#125;local inputMap = &#123;&#125;local playList = &#123;&#125;local playFrame = 0local frame = 0local userCount = 0print("start")while (true) do local event = host:service(17) while (event) do local type, ip, data = Lib.Recv(event) if (type == "input") then inputMap[ip] = data elseif (type == "connect") then event.peer:timeout(10, 3000, 5000) local data = &#123;ip = ip, x = math.random(0, 800), y = math.random(0, 600)&#125; for k, v in pairs(peerMap) do Lib.Send(v, "addNewUser", data) end peerMap[ip] = event.peer dataMap[ip] = data inputMap[ip] = &#123;&#125; userCount = userCount + 1 Lib.Send(event.peer, "loginSuccess", &#123;ip = ip, users = dataMap, playList = playList&#125;) print("connect", ip) elseif (type == "disconnect") then peerMap[ip] = nil dataMap[ip] = nil inputMap[ip] = nil userCount = userCount - 1 for k, v in pairs(peerMap) do Lib.Send(v, "delUser", ip) end event.peer:disconnect(-1) print("disconnect", ip) end event = host:service() end if (userCount &gt; 0) then frame = frame + 1 if (frame % 3 == 0) then playFrame = playFrame + 1 print(playFrame) for k, v in pairs(peerMap) do Lib.Send(v, "play", inputMap) end playList[#playList + 1] = Lib.Clone(inputMap) end endend 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149--main.lualocal Actor = require("actor")local Lib = require("lib")local Enet = require ("enet")local userList = &#123;&#125;local userMap = &#123;&#125;local input = &#123;&#125;local playList = &#123;&#125;local playFrame = 0local perdt = 17local timer = 0local frame = 0local playerlocal fps = 0local timer2 = 0local host = Enet.host_create()local server = host:connect("localhost:6789")local function NewActor(x, y, ip) local actor = Actor.New(x, y, ip) userMap[ip] = actor userList[#userList + 1] = actor return actorendlocal function Update() if ((frame + 1) % 3 == 0 and #playList == 0) then return end frame = frame + 1 fps = fps + 1 if (frame % 3 == 0) then for k, v in pairs(playList[1]) do if (userMap[k]) then userMap[k].input = v end end playFrame = playFrame + 1 table.remove(playList, 1) end for n=1, #userList do userList[n]:Update() endendfunction love.load() local event, type, ip, data repeat event = host:service() if (event) then type, ip, data = Lib.Recv(event) end until event ~= nil and type == "loginSuccess" for k, v in pairs(data.users) do local actor = NewActor(v.x, v.y, v.ip) if (v.ip == data.ip) then player = actor print("loginSuccess", v.ip) end end playList = data.playList while (#playList &gt; 0) do Update() endendfunction love.update(dt) local event = host:service() while event do local type, ip, data = Lib.Recv(event) if (type == "play") then playList[#playList + 1] = data elseif (type == "addNewUser") then NewActor(data.x, data.y, data.ip) elseif (type == "delUser") then userMap[data] = nil for n=#userList, 1, -1 do if (userList[n].ip == data) then table.remove(userList, n) end end end event = host:service() end dt = math.floor(dt * 1000) timer = timer + dt while (timer &gt;= perdt) do --print(#playList) if ((frame + 1) % 3 == 0 and #playList &gt; 1) then while (#playList &gt; 0) do Update() end else Update() end timer = timer - perdt end timer2 = timer2 + dt if (timer2 &gt;= 1000) then --print(timer2, fps) fps = 0 timer2 = timer2 - 1000 endendfunction love.draw() for n=1, #userList do userList[n]:Draw() end love.graphics.print(playFrame, 5, 5)endfunction love.keypressed(key) if (key == "up" or key == "down" or key == "left" or key == "right") then input[key] = 1 Lib.Send(server, "input", input) endendfunction love.keyreleased(key) if (key == "up" or key == "down" or key == "left" or key == "right") then input[key] = 0 Lib.Send(server, "input", input) endend 从代码中可以看出，以上实现便是Skywind所说的乐观帧锁定。事实上我认为传统的帧同步（Lockstep）并不适合网络游戏，甚至只是一种早期的理论模型。在实际应用还是要以乐观帧锁定为准。关于乐观帧锁定的实现原理我便不再复述，只说说实际开发中遇到的一些问题。 Fixed Update 很抱歉我找不到这个词对应的中文词汇，直译过来的意思便是“固定的更新”。在实际应用的含义为，每隔一段时间便会Update一次，如果遇到卡住之类导致积累了很长时间的行为，则会根据时间一次性进行多次Update。也就是这段代码： 123456789101112131415--Fixed Update(main.lua)timer = timer + dtwhile (timer &gt;= perdt) do if ((frame + 1) % 3 == 0 and #playList &gt; 1) then while (#playList &gt; 0) do Update() end else Update() end timer = timer - perdtend 使用了Fixed Update后，你的游戏进度便由时间牢牢把控住，这样便能摆脱帧率的影响。在业务层也不再需要使用DT(Delta Time)了，而是采用一个固定的值（譬如1 / 60）。这个概念很重要，因为过快与过慢的帧率都会与同步不那么搭调。 收发频率 按照Skywind的说法是服务端每秒20-50次向所有客户端发送同步包。这里我们需要理清乐观帧锁定的本质：就是服务端每隔一段时间发送同步包，然后客户端每隔一段时间接收并应用之，如果在那段时间内没有收到，就持续等待。所以我们必须设置好合适的时间，令服务端和客户端之间配合无间。 在我的设计里，为服务端和客户端都设置了帧（Frame）的概念，每Update一次即是一帧，每次Update的间隔时间为17毫秒，这个数字是根据(1/60)秒取整得出。每隔三帧服务端便会发送同步包，而客户端则是每帧都会接收，每隔三帧便会应用之。我称这种每隔三帧的帧为同步帧。 衡量设置是否良好，主要看每帧接收的同步包的数量，以及每秒帧数的多少。正常情况下，每帧接收的同步包的数量应是0-1，如果超过这个数值，证明服务端或客户端其中一方的频率太快或太慢。至于每秒帧数的多少，则能看出发送频率是否过剩，正常情况下在60左右即可，这和FPS的要求是类似的。 1local event = host:service(17) --服务端每隔17毫秒接收一次封包 收包Q&amp;A 关于收包的问题，有个最明显的问题便是为何不是在同步帧时进行收包，而是每帧都尝试收包？ 这是因为收包的内容不仅仅是关于帧同步，还可能有其他东西。其次便是先收后收并不影响什么，以及每隔三帧才进行一次收包恐怕会卡。 关于一次性收到多个同步包的情况时，该怎么办？ 遇到收到多个同步包的情况，说明客户端失联了一段时间，这时候便需要一次性进行多次Update以迅速追回进度。 既然确定遇到多个同步包时需要一次性追回进度，那为何不选择在接收后立即执行，而要等到同步帧？ 因为基本上不会遇到这种情况，能遇到多个同步包的情况，一般客户端已经在等待了。换做客户端卡住这种情况的话，根据Fixed Update的规则，本来就会立即赶到同步帧的。 为何等待同步包的代码并非是阻塞式的，而是每帧去判定一下？ 因为如果是阻塞式的话，会使得DT变得很大，影响Fixed Update。 输入应用 关于输入应用方面，首先要明确一点：客户端每次按下/释放按键，就会改写输入表然后发送之。服务端收到后便会改写在服务端的对应输入表。这种模式在高延迟的表现便是呈现出某些按键因为一直按下而导致一些鬼畜操作，这点算是可以接受的。 另外注意不要贪图方便每次只发送当前修改的按键，这样会失去输入的稳定性，一旦发生丢包之类的，会产生键盘失灵的感觉。 在每次同步帧时便会根据同步包的内容更新所有玩家的输入表，从而改变每个联机角色的操作。这个输入表会一直应用到下次同步帧之前，从这点来看帧同步也是一种回合制。 123456789101112--根据同步包的内容更新所有玩家的输入表(main.lua)if (frame % 3 == 0) then for k, v in pairs(playList[1]) do if (userMap[k]) then userMap[k].input = v end end playFrame = playFrame + 1 table.remove(playList, 1)end 123456789101112131415--客户端每次按下/释放按键，就会改写输入表然后发送之(main.lua)function love.keypressed(key) if (key == "up" or key == "down" or key == "left" or key == "right") then input[key] = 1 Lib.Send(server, "input", input) endendfunction love.keyreleased(key) if (key == "up" or key == "down" or key == "left" or key == "right") then input[key] = 0 Lib.Send(server, "input", input) endend 断线重连/中途加入 想要做到这两点，便需要做到在服务端保存每一份同步包，这样服务端只需要记录每个玩家的初始数据，在新玩家加入游戏时，首先发送每个玩家的初始数据给新玩家同步，然后再把所有同步包打包发送给新玩家，让新玩家一次性Update，即可完成中途加入。当然不要忘记给现有玩家发送新玩家的数据。 1234567891011121314151617181920212223242526--新玩家同步(main.lua)local event, type, ip, datarepeat event = host:service() if (event) then type, ip, data = Lib.Recv(event) enduntil event ~= nil and type == "loginSuccess"for k, v in pairs(data.users) do local actor = NewActor(v.x, v.y, v.ip) if (v.ip == data.ip) then player = actor print("loginSuccess", v.ip) endendplayList = data.playListwhile (#playList &gt; 0) do Update()end 浮点数 根据网上的信息看来，浮点数因为在不同环境的实现有所偏差，所以可能会导致不一致的问题，这样便会产生蝴蝶效应，最终导致同步失效。目前我使用LuaJIT在Windows(x64)、Ubuntu(x64)、macOS、Android(红米Note4)、iOS测试来看，浮点数在「输出」的场合下并无不同。当然只是输出，并不能代表真实数据的情况。以及我的测试范本并不算多，对于浮点数的问题还不敢保证。所以我选择在业务层放弃使用浮点数，相关数据都事先进行转换，到最后需要浮点数的对接场合再进行转换。当然我并不敢保证这种做法的可行性，真正成熟的做法应该是使用定点数，但我暂时并未这么做。 1dt = math.floor(dt * 1000) -- 浮点数转换为整数（毫秒） 后记 以上便是本次我对帧同步的初步探究，它注定是不成熟的，需要经过实践的检验，接下来我会考虑将其接入到一些项目中。有相关经验的朋友欢迎前来讨论。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DNF的SPK文件解析笔记]]></title>
      <url>%2F2017%2F07%2F21%2Fspk_analysis%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 SPK文件是DNF的一种更新时所用的压缩包（国服除外），在更新时会从服务器下载这种SPK文件然后于本地解压。有时候为了获得更快的速度，以及突破墙的限制，我们通过获取到更新服务器的网址直接下载。但是此刻对于如何将SPK文件解压便是个问题了，本文遂由此而生。 详解 SPK文件的本质上是将原文件按照一定规则进行分割成多个片段，然后对这些片段使用bzip2算法进行压缩。以下是文件结构图： 由于信息的不对称，导致不少地方是处于盲区的，不过这并不影响获取到关键数据。这种被压缩的片段开头标识为”BZh91AY&amp;SY”，所以只需要以此为关键字进行分割就能得出关键数据了，不过实际操作时发现除了压缩数据之外还有非压缩数据，并且会用一段48字节的数据进行分隔。且拥有非压缩数据的片段结尾也会有一段意味不明的数据，好在它们都有对应的开头标识，进行分割即可。 在得出压缩数据后使用bzip2算法进行解压缩，然后将所有解压后的数据与非压缩数据按顺序进行拼接，每个片段如此类推最后总体拼接起来即可得到完整的原文件。本次解析使用的环境是Python3.6，以下是过程代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243import sysimport bz2import structHEADER = b"BZh91AY&amp;SY"MARK = b"\x00\x00\x00\x00\x00\x10\x0e\x00\xff\xff\xff\xff\xff\xef\xf1\xff"# 00 00 00 00 00 10 0E 00 FF FF FF FF FF EF F1 FFTAIL = b"\x01\x00\x00\x00" # 01 00 00 00def decompress_spk(path): f = open(path, "rb") f.read(4) # unknown, all files are same. f.read(260) # total 260 bits, contain name and buffer. f.read(4) # unknown, all files are same. struct.unpack('i', f.read(4))[0] # decompress_size content = f.read() parts = content.split(HEADER) f.close() new_content = b"" for n in range(1, len(parts)): lst = parts[n].split(MARK) length = len(lst) new_content = new_content + bz2.decompress(HEADER + lst[0]) if length &gt; 1: for m in range(1, length - 1): new_content = new_content + lst[m][32:] pos = lst[length - 1].rfind(TAIL) new_content = new_content + lst[length - 1][32:pos] f2 = open(path[:-4], "wb") f2.write(new_content) f2.close()if __name__ == "__main__" and len(sys.argv) &gt; 1: decompress_spk(sys.argv[1]) 后记 事实上这种SPK的压缩机制效果根本是微乎其微，我完全不明白Neople这么做的用意。以及片段的划分机制和诸多盲区都没搞懂，看来我得考虑学下逆向方面的知识了。不过无论如何，最终要达到的目标还是做到了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于Socket.listen方法的一点体悟]]></title>
      <url>%2F2017%2F07%2F16%2Fsocket_listen%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 最近在接触Socket的的时候，关于其中的listen方法感到不解，于是对其进行了一番研究，得出了一点体悟，特此记录。 详解 让我们先来看看listen方法在Python3.6文档说明： 1234567socket.listen([backlog])Enable a server to accept connections. If backlog is specified, it must be at least 0 (if it is lower, it is set to 0); it specifies the number of unaccepted connections that the system will allow before refusing new connections. If not specified, a default reasonable value is chosen.启用服务器以接受连接。如果指定backlog，则必须至少为0（如果低于0，则设置为0）；它指定系统在拒绝新连接之前将允许的未接受连接的数量。如果未指定，则选择默认的合理值。Changed in version 3.5: The backlog parameter is now optional.在版本3.5中已更改： backlog参数现在是可选的。 起初我看了这说明想当然的以为是可以接入的Client上限，不过实践过后发现并非如此。在网上找的解答基本上就是文档所言的复述，后来请教了专业人士后，方知这涉及到Socket的底层知识。 在了解listen方法之前，首先我们需要了解connect方法和accept方法，以下是文档说明： 12345678910socket.connect(address)Connect to a remote socket at address. (The format of address depends on the address family — see above.)在地址连接到远程套接字。（地址的格式取决于地址系列 - 请参见上文）If the connection is interrupted by a signal, the method waits until the connection completes, or raise a socket.timeout on timeout, if the signal handler doesn’t raise an exception and the socket is blocking or has a timeout. For non-blocking sockets, the method raises an InterruptedError exception if the connection is interrupted by a signal (or the exception raised by the signal handler).如果连接被信号中断，则该方法等待直到连接完成，或者如果信号处理程序没有引发异常并且套接字正在阻塞或者已经阻塞，则在超时时引入socket.timeout超时。对于非阻塞套接字，如果连接被信号中断（或由信号处理程序引发的异常），则该方法引发InterruptedError异常。Changed in version 3.5: The method now waits until the connection completes instead of raising an InterruptedError exception if the connection is interrupted by a signal, the signal handler doesn’t raise an exception and the socket is blocking or has a timeout (see the PEP 475 for the rationale).在版本3.5中已更改：该方法现在等待直到连接完成，而不是提高InterruptedError异常，如果连接被信号中断，信号处理程序不引发异常，套接字阻塞或超时（参见 PEP 475）。 12345678910111213socket.accept()Accept a connection. The socket must be bound to an address and listening for connections. The return value is a pair (conn, address) where conn is a new socket object usable to send and receive data on the connection, and address is the address bound to the socket on the other end of the connection.接收一个连接.该socket 必须要绑定一个地址和监听连接.返回值是一对（conn， 地址）其中conn是新 t4 &gt; socket对象可用于在连接上发送和接收数据，address是连接另一端的套接字的地址。The newly created socket is non-inheritable.新创建的套接字non-inheritable。Changed in version 3.4: The socket is now non-inheritable.在版本3.4中更改：套接字现在是不可继承的。Changed in version 3.5: If the system call is interrupted and the signal handler does not raise an exception, the method now retries the system call instead of raising an InterruptedError exception (see PEP 475 for the rationale).在版本3.5中更改：如果系统调用中断并且信号处理程序没有引发异常，则此方法现在重试系统调用，而不是引发InterruptedError异常 PEP 475）。 相比listen方法，它俩就好理解多了，一个是Client用于连接Server的方法，一个是Server用于接收Client的连接申请的方法。 但事实上accept方法一次只能接收一个Client的连接申请，而Client则是多个的，这样Socket会设计一个队列来存储Client的连接申请则是理所当然的。于是accept便从这个队列里提取首位成员处理即可。以下是示意图： 如此便很清晰了，backlog参数的含义便是这个队列的最大值，也就是同时受理连接申请的最大值。关于backlog该设置为多少，从Skynet得到的参考为32。如果满了便需要Client重新connect。以上listen方法之谜便解开了。 后记 不得不说网络编程的水真的很深，我也得买点书充充电了，目前的目标为啃下谢希仁著的《计算机网络》。另外推荐《TCP/IP详解》及《UNIX网络编程》。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于MVC框架的一点体悟]]></title>
      <url>%2F2017%2F06%2F16%2Fmvc_thinking%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 MVC框架相信大家都有所耳闻，不过想必没有深入接触的话，大多是知其然而不知其所以然。而本人几乎没有GUI软件的开发经验，只是走马观花般的碰过几下.NET的Winform之类，所以之前自然也是如此。 而近日帮助友人使用C++/CLI完成一款篮球比赛记录软件，在思考要如何搭建架构时很自然的选择了将核心和界面分离的设计，在完成后我感觉Winform把自动生成的代码和人为实现的事件接口放一起很是冗杂。于是选择用Python重新实现一次，随着把界面数据和事件接口的分离，赫然发现：这不就是传说中的MVC框架么？ 详解 当然有一点是需要明确的：我实现的这套「MVC框架」并不算标准，并且为了便利性还牺牲了一点解耦性，以下仅供参考。 以上的core, interface, design分别是三个模块，代表着MVC框架下的model, controller, view。箭头表明了引用关系（例：interface调用了core的功能）。 如图所示，interface和design都引用了core，而core并没有引用其他模块。由此可见，core是完全独立于界面的，无论是怎样的界面，只要对接好core就没有问题，这正是「业务和界面分离」。 而interface和design，实际上是可以解耦的。不过这需要令design使用一些手段监听core的数据是否发生了变化，我认为这样的实现颇为复杂，况且interface和design本为一一对应的关系（interface是界面事件，design是界面数据），所以也不必苛求解耦。遂选择由interface通知design去同步core的数据。 演示 本演示使用Python3编写，界面使用了Pyqt5，理解这个演示你需要了解Python以及Qt。项目地址:MVCShow.git 演示的内容十分简单，仅是一个窗口包含了一个文本框和按钮而已。通过点击按钮来改变文本框的内容。 点击前： 点击后： 流程图： 代码展示： 123456789101112# core__value = "123"def set_value(value): global __value __value = valuedef get_value(): return __value 123456789101112131415161718192021222324252627282930# designimport corefrom PyQt5 import QtCore, QtWidgetsfrom PyQt5.QtWidgets import QMainWindowclass EntryDesign(QMainWindow): def __init__(self): super(EntryDesign, self).__init__() self.setObjectName("MVCShow") self.resize(400, 300) self.pushButton = QtWidgets.QPushButton(self) self.pushButton.setGeometry(QtCore.QRect(150, 210, 113, 32)) self.pushButton.setObjectName("pushButton") self.lineEdit = QtWidgets.QLineEdit(self) self.lineEdit.setGeometry(QtCore.QRect(150, 110, 113, 21)) self.lineEdit.setObjectName("lineEdit") self.retranslateUi() QtCore.QMetaObject.connectSlotsByName(self) def retranslateUi(self): _translate = QtCore.QCoreApplication.translate self.setWindowTitle(_translate("MVCShow", "MVCShow")) self.pushButton.setText(_translate("MVCShow", "click")) def refresh(self): self.lineEdit.setText(core.get_value()) 1234567891011121314151617# interfaceimport corefrom design.entry import EntryDesignclass Entry(EntryDesign): def __init__(self, ): super(Entry, self).__init__() self.pushButton.clicked.connect(self.__pushButton_clicked) def showEvent(self, event): self.refresh() def __pushButton_clicked(self): core.set_value("456") self.refresh() 后记 框架是死的，思想是活的。在实际开发中，并不需要教科书般地去套用模板，事实上大家实现的MVC框架也不尽相同。而我认为MVC框架的核心思想便是「界面与业务分离，数据与逻辑分离」。只要把握好这个核心思想去做即可。对此有所心得者，欢迎前来探讨，提供更佳的思路。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于像素PNG图片在游戏引擎缩放后出现毛边的解决方案]]></title>
      <url>%2F2017%2F05%2F01%2Fpng_stroke_problem%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 今日遇到了一个很值得记录的问题：对于像素PNG图片在游戏引擎里缩放后，便会在图片边缘出现很奇怪的毛边。类似这样： 经过研究发现，似乎与文件格式无关。我还尝试将不会出现毛边的像素图混搭一块，结果反而导致靠近毛边的地方会被感染： 当然这个问题在Unity下是可以通过设置解决的： 不过并非所有游戏引擎都能这么做的，所以还需要从文件根本上解决。经过一段无心插柳的尝试，发现解决方案为使用PS的文件→存储为Web所用格式： 关键便在于将杂边设置为“无”，保存后再拿去测试，问题解决： 虽然到头来具体的原理还是没有弄明白，但好歹也算是解决了。如果有人明白具体原理，还请不吝赐教。至于这么做是否有损尚未可知，但从肉眼来看是不成问题的。以及这个问题目前只发现出现在像素图上，带半透明的特效图并无此问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[观察者模式的一种实现——Caller]]></title>
      <url>%2F2017%2F04%2F21%2Fcaller%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 在程序设计的时候，观察者模式是一种应用广泛的设计模式，它是一种模块间的通信方式，对于程序的解耦性有所帮助。本文便提供了一种实现思路，也即是说，你需要先去了解观察者模式才方便阅读本文。 以下代码演示将使用Lua语言，接下来的内容对阅读者的Lua水平有一定的要求。如果你不知道在Lua中class的实现方式，可参考这篇文章。 实现 首先构造Caller的结构关系，如图所示： 由此可见，Caller包含一个结构体——Listener。接下来是代码实现： 1234567891011121314151617181920212223242526272829303132-- Caller.lualocal Class = require("class")local Caller = Class()function Caller:Ctor() self.listenerList = &#123;&#125;endfunction Caller:AddListener(obj, func) table.insert(self.listenerList, &#123;obj = obj, func = func&#125;) -- Create Listener.endfunction Caller:DelListener(obj, func) for n=#self.listenerList, 1, -1 do if (self.listenerList[n].obj == obj and self.listenerList[n].func == func) then table.remove(self.listenerList, n) return true end end return falseendfunction Caller:Call(...) for n=1, #self.listenerList do self.listenerList[n].func(self.listenerList[n].obj, ...) endendreturn Caller 应用12345678910111213141516171819-- A.lualocal Class = require("class")local Caller = require("caller")local B = require("b")local A = Class()function A:Ctor() self.caller = Caller.New() self.b = B.New(self.caller) self.value = 0endfunction A:SetValue(value) self.value = value self.caller:Call(value)endreturn A 1234567891011121314-- B.lualocal Class = require("class")local B = Class()function B:Ctor(caller) caller:AddListener(self, self.Print)endfunction B:Print(...) print(...)endreturn B 如上所示，在调用A:SetValue(value)时会连带调用B:Print(…)，如此只需要通过操作Caller就能达到不同对象之间通信的效果。并且也无须将业务写死在A:SetValue(value)中，业务将集中存放在Caller中。 疑难解答 问：Caller的缺点是什么？ 答：Caller的缺点的很明显，需要将Caller对象直传到其他模块处，这样并不是很安全（别处也可以做Caller的一切行为）。当然这个问题也很好解决，只需要采用Event机制对其进行封装即可。代码如下： 12345678910111213141516171819202122232425262728-- A.lualocal Class = require("class")local Caller = require("caller")local B = require("b")local A = Class()function A:Ctor() self.event = function(...) self:OnEvent(...) end self.caller = Caller.New() self.b = B.New() self.value = 0endfunction A:SetValue(value) self.value = value self.caller:Call(value)endfunction A:OnEvent(type, ...) if (type == "AddListener") then return self.caller:AddListener(...) end return "No Event"endreturn A 1234567891011121314-- B.lualocal Class = require("class")local B = Class()function B:Ctor(upperEvent) upperEvent("AddListener", self, self.Print)endfunction B:Print(...) print(...)endreturn B 问：Caller在功能上有何可改进之处？ 答：在实际开发中，Caller的需求数量一般不止一个，届时可以考虑用List或Map对Caller进行管理。也可以考虑直接让Caller具备管理多个ListenerList，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748-- Caller.lualocal Class = require("class")local Caller = Class()function Caller:Ctor() self.listenerListMap = &#123;&#125;endfunction Caller:AddListener(type, obj, func) if (not self.listenerListMap[type]) then self.listenerListMap[type] = &#123;&#125; end table.insert(self.listenerListMap[type], &#123;obj = obj, func = func&#125;) -- Create Listener.endfunction Caller:DelListener(type, obj, func) if (not self.listenerListMap[type]) then return false end local listenerList = self.listenerListMap[type] for n=#listenerList, 1, -1 do if (listenerList[n].func == func and listenerList[n].obj == obj) then table.remove(listenerList, n) return true end end return falseendfunction Caller:Call(type, ...) if (not self.listenerListMap[type]) then return end local listenerList = self.listenerListMap[type] for n=#listenerList, 1, -1 do listenerList[n].func(listenerList[n].obj, ...) endendreturn Caller 后记 以上内容仅为提供一个思路，它或许并非最完善的，也不一定能适用于所有编程语言中，对此有所心得者，欢迎前来探讨，提供更佳的思路。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈对象之间通信的解决方案——Event机制]]></title>
      <url>%2F2017%2F04%2F19%2Fevent_mechanism%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 在程序设计的时候，不同对象与模块间总是不可避免会发生相互调用的情况，如果选择将对象互相作为参数传入给对方使用，那么这种现象一般被称为耦合，这样实际上就让两个部分连在了一块。当然这样子实际上并没有什么问题，只要这符合你的设计预期。只是一旦开发规模增大、开发人员增多、耦合程度加剧的话，程序的维护成本也便会随之剧增。往往会出现某个模块在另一个模块处被做了一些修改而不自知，以及在脚本语言的情况下，没有private保护的对象到了他处等同彻底的暴露，随便的修改的话，封装性也随之不存。那么由此看来，必须拥有一套对象之间通信的解决方案了，本文便是提供了一种思路供给参考。 以下代码演示将使用Lua语言，接下来的内容对阅读者的Lua水平有一定的要求。如果你不知道在Lua中class的实现方式，可参考这篇文章。 使用机制之前的做法 首先我们演示一下不用Event机制之前的做法，也就是一般人会用的做法。 123456789101112-- A.lualocal Class = require("class")local A = Class()local B = require("b")function A:Ctor() self.value = 1 self.b = B.New(self)endreturn A 1234567891011121314-- B.lualocal Class = require("class")local B = Class()function B:Ctor(a) self.a = aendfunction B:Print() print(self.a.value)endreturn B 使用机制之后的做法 由上可以看出，这种直传对象的做法其实是十分危险的，它很容易破坏封装性，并且会达到「你中有我，我中有你」的效果，并且这还是在上下级的情况下。接下来便演示下使用了Event机制后的做法。 123456789101112131415161718192021-- A.lualocal Class = require("class")local A = Class()local B = require("b")function A:Ctor() self.value = 1 self.event = function(self, ...) self:OnEvent(...) end self.b = B.New(self.event)endfunction A:OnEvent(type, ...) if (type == "GetValue") then return self.value end return "No Event"endreturn A 1234567891011121314-- B.lualocal Class = require("class")local B = Class()function B:Ctor(upperEvent) self.upperEvent = upperEventendfunction B:Print() print(self.upperEvent("GetValue"))endreturn B 通过对比可以看出，使用了Event机制后，不仅保证了封装性，而且还隔离了A对象的实现，换句话说，B对象的upperEvent已经不仅限于A了，只要是提供了一致的Event接口即可，并且A对象还能清除的知道自己对外究竟提供了什么接口，可维护性也随之提高了。 当然代价还是有的，那便是调用Event时的函数调用次数比传统方式有所增加，但我认为这是值得的。当然这只是一种思路，也未尝不可优化。 疑难解答 问：关于两个平级对象需要相互调用要怎么做？ 答：参考以下例子： 12345678910111213141516171819202122232425-- A.lualocal Class = require("class")local A = Class()local B = require("b")local C = require("c")function A:Ctor() self.value = 1 self.event = function(self, ...) self:OnEvent(...) end self.b = B.New(self.event) self.c = C.New(self.event)endfunction A:OnEvent(type, ...) if (type == "GetValue") then return self.b:GetValue() elseif (type == "SetTag") then return self.c:SetValue(...) end return "No Event"endreturn A 1234567891011121314151617-- B.lualocal Class = require("class")local B = Class()function B:Ctor(upperEvent) self.upperEvent = upperEvent self.value = 1 self.upperEvent("SetTag", "123")endfunction B:GetValue() return self.valueendreturn B 12345678910111213141516171819-- C.lualocal Class = require("class")local C = Class()function C:Ctor(upperEvent) self.upperEvent = upperEvent self.tag = ""endfunction C:SetTag(tag) self.tag = tagendfunction C:Print() print(self.upperEvent("GetValue"))endreturn C 由此可见，平级对象的相互调用，只需要统一由上级管理好需要调用的接口，然后平级对象从上级Event中获取即可。 问：一个对象可以拥有多个OnEvent()么？也就是针对不同对象派出不同的Event。 答：一般来说不推荐这么做，因为这只会使得维护成本提升。当然你很清楚自己的需求以及这么做的代价的话，但试无妨。 问：使用Event机制后有效的保证了封装性，但是对于上级管理下级的时候并不存在这种封装性的保护，那么该怎么办呢？ 答：这个在脚本语言里是一个没办法的事，原则上最好是不要对外直接暴露变量，只使用函数。哪怕这会带来更高的性能代价，对于维护性而言也是值得的，当然这个问题或许也可以通过特殊的手段解决（参考Lua元表的内容）。 问：是不是严格意义所有情况下都不应该直传对象而采用Event呢？ 答：这样显然是不现实的，比如某些类的业务本身就需要获取到对象本身（如容器），以及Event本身也是有性能代价以及构建成本的，不可能面面俱到。在某些你认为必要且可掌控的情况下，直传对象也并非不可以。毕竟解耦的目的也是为了提高可维护性，只要你觉得这样做是可以接受的，那么便可以了。 后记 以上内容仅为提供一个思路，它或许并非最完善的，也不一定能适用于所有编程语言中，对此有所心得者，欢迎前来探讨，提供更佳的思路。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[更换Homebrew的更新源]]></title>
      <url>%2F2017%2F03%2F29%2Fbrew_changing%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 更换Homebrew的更新源的教程，在网上数不胜数，然内容大多大同小异且述之不详，且未提及版本上的差异。故作此文，以正视听。 在阅读此文之前，你需要了解Homebrew和Git并安装了它们。并且对于Homebrew官方更新源的速度赶到不满且不打算利用其它手段解决（如VPN），或者看了其它文章感到不求甚解，那么此文对你而言是有价值的。 更新源的机制 Homebrew的更新源由三部分组成：本体（brew.git）、核心（homebrew-core.git）以及二进制预编译包（homebrew-bottles）。 在很多教程中，只会提及到更换本体，而未涉及到核心与二进制预编译包的更换。这样实际上效果是不完全的（尽管这样也无法做到完全，毕竟有一些软件包的地址是不被收录的，只能从它们提供的链接处下载）。 从.git的后缀名可以看出，Homebrew的更新源是以Git仓库的形式存在的，这便是为什么需要用到Git的原因。也正是如此，使得可以对其进行克隆，成为新源。 更新源的选择 默认官方的更新源都是存放在GitHub上的，这也是中国大陆用户访问缓慢的原因，一般来说我们会更倾向选择国内提供的更新源，在此推荐中国科大以及清华大学提供的更新源，因为它们能够完整以上源组成的三个部分。并且在此感谢他们为大家提供的服务。 替换更新源123456789101112131415161718192021222324# 替换brew.git:$ cd "$(brew --repo)"# 中国科大:$ git remote set-url origin https://mirrors.ustc.edu.cn/brew.git# 清华大学:$ git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git# 替换homebrew-core.git:$ cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"# 中国科大:$ git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git# 清华大学:$ git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git# 替换homebrew-bottles:# 中国科大:$ echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles' &gt;&gt; ~/.bash_profile$ source ~/.bash_profile# 清华大学:$ echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles' &gt;&gt; ~/.bash_profile$ source ~/.bash_profile# 应用生效:$ brew update 以上在中国科大和清华大学任选其一即可，在使用其他源的时候，最好先尝试访问其链接看看是否健在，并且因为历史原因，最初的brew.git是叫homebrew.git的，而现在部分更新源早已随官方更名，所以切记要验证。 并且没有严格规定必须三个组成部分必须是来自同一提供，可随性发挥。 且Homebrew在早期版本中更新源的是在/usr/local目录下的，而现在是在/usr/local/Homebrew，不过应该都是可以使用&quot;$(brew --repo)&quot;来自动指向目录的，所以无需理会。 如果你之前折腾过不少导致你的Homebrew有点问题，那么可以尝试使用如下方案： 123456789101112131415# 诊断Homebrew的问题:$ brew doctor# 重置brew.git设置:$ cd "$(brew --repo)"$ git fetch$ git reset --hard origin/master# homebrew-core.git同理:$ cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"$ git fetch$ git reset --hard origin/master# 应用生效:$ brew update 重置更新源 所谓有进则有退，在某些时候也有换回官方源的需求。 1234567# 重置brew.git:$ cd "$(brew --repo)"$ git remote set-url origin https://github.com/Homebrew/brew.git# 重置homebrew-core.git:$ cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"$ git remote set-url origin https://github.com/Homebrew/homebrew-core.git 至于homebrew-bottles，本质上作为一个环境变量的存在，之前的命令也只是将其写入到/usr/.bash_profile中，并且只是在文件尾部添加一行。所以之前的命令不推荐重复执行，在未掌握相关命令技巧的前提下，我推荐直接去修改.bash_profile文件： 当然这里的主题是重置更新源，所以我们直接选择删除环境变量HOMEBREW_BOTTLE_DOMAIN，使其成为默认值即可。 当然，最后不要忘记$ brew update进行应用。 后记 在完成更新源的更换后，我们可以使用$ brew upgrade将现有的软件进行更新至最新版本，这样便能很直接的看出速度上的变化了。最后不要忘记$ brew cleanup将旧有的软件安装包进行清理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[王牌英雄(Awesomenauts)研究报告]]></title>
      <url>%2F2017%2F03%2F03%2Fresearch_awesomenauts%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 出于项目的需要，需要对市面上的横版MOBA动作游戏进行研究，特撰此文，以便记录和交流。本文将对《王牌英雄》分为几个部分进行研究并以章节的形式体现，文中观点仅为本人一家之言，仅供参考。 介绍 《王牌英雄》是一款由Ronimo Games制作，DTP Entertainment发行于2012年的2D横版动作游戏。游戏平台繁多，包括Windows、macOS、Linux、PS3、PS4、Xbox360、Xbox One。玩家可于Steam、PSN和XBLA进行购买下载。 游戏虽然是2D横版动作游戏，但其实他更讲究玩家间的对抗，属于MOBA游戏，而且武器、职业和招式的种类也繁多非常值得多人一起游戏。 《王牌英雄》主要讲述了星系间的领土争夺战争，巨型机器人、外星人等都会成为出战角色。 与众多的MOBA游戏类似，《王牌英雄》也是以与队友（3V3）合作，摧毁敌方的基地为胜利目标。一场游戏的时间大致在10-15分钟，拥有PVE/PVP两种模式，可进行各种设置以增添游戏特色。 地图前言 地图分为上下两路，需要利用跳跃到踏板上进行Y轴移动。拥有多张地图，但皆大同小异。总体结构如下图： 要素 商店 商店是英雄支付太阳能以强化技能的地方，并提供了恢复功能。 商店属于阵营设施，位于阵营的最深处，可视为传统MOBA的泉水。 基地 基地属于阵营设施，可摧毁，位于商店之前，是阵营的核心，若基地被摧毁，则视为游戏失败。 基地不会攻击，不会自我恢复，敌人不可通过。 屏障 屏障属于阵营设施，位于地图各处，敌人不可通过。 工厂 工厂属于阵营设施，位于基地下方，负责生成士兵。 塔 塔属于阵营设施，可摧毁，位于上下二路，每路各有两座。 负责攻击附近的敌人，敌人不可通过。 攻击方式为多角度子弹，且只会锁定并伤害一个单位（单一伤害）。 在建筑本身还有一个群体伤害判定，强行通过时会触发。 士兵 士兵属于阵营单位，可摧毁，敌人不可通过（会将士兵推后），从工厂诞生，前往上下二路。（前往上路需要跳跃/飞行等方式）目标为攻击敌人，拥有两种类型。 士兵分为三个等级，每隔6分钟升级一次。升级后士兵的属性将会得到提升。（用于推进游戏节奏） 种类 近战兵 最基础的种类，每隔20秒诞生2个。 攻击方式为齿轮切割，属于单一伤害。和塔一样，强行通过时会被连带攻击。 超级兵 当摧毁敌方线上的1座塔后，便会诞生1个。 攻击方式为发射炮弹，碰到第一个敌人后爆炸，属于群体伤害。 英雄 英雄属于阵营单位，可摧毁，敌人不可通过，从基地诞生，由玩家控制。 英雄死亡后隔一段时间后便会从基地复活，随着游戏时间的增长，复活时间也会增长。 野怪 野怪属于公共单位，可摧毁，位于地图中间的几个固定点，目标为攻击进犯者，在不同地图上拥有不同类型，每隔一段时间刷新。 英雄可通过击杀之获得太阳能和恢复。 踏板 踏板属于公共设施，位于地图各处，可供单位立足，且玩家可通过↓+Space穿透踏板进行下降。 隐藏区域 隐藏区域属于公共设施，位于地图各处，一般会搭配踏板使用，外界无法看到隐藏区域里面的情况。 补给球 补给球属于公共设施，位于地图各处，受伤时的英雄触碰后可恢复，然后补给球消失，每隔一段时间刷新。 太阳能结晶 太阳能结晶属于公共设施，位于地图各处，诞生自士兵死亡后，英雄触碰后可获得太阳能。 太阳能分为两种：灰色和黄色，灰色可获得1点太阳能，黄色为5点。 后记 总体来说，《王牌英雄》的地图设计视图让玩家频繁的使用跳跃，利用踏板借助跳跃来增加游戏的操作性，弥补非深度横版的躲招问题。意图不错，不过反倒增加了操作难度，若要考虑移植到手机平台的话，这将是个问题。 地图中间的野怪设计，可以视为玩家发生冲突时随手杀死野怪以获得恢复的手段。不过结合游戏时间来看，野区其实可以设计一些加剧玩家冲突与游戏节奏的元素。 士兵的作用非常明显，在英雄单独对抗士兵时，会付出一定程度的代价。不过超级兵的诞生频率太低，几乎没有存在感，作用也相对有限了。 英雄前言 英雄即玩家参与游戏时扮演的角色，《王牌英雄》的英雄数量繁多，至今发展到几十个左右。 特性 《王牌英雄》将英雄做了不同特性的划分，每个英雄可能包括多个特性，以下是特性一览： 刺客 入门角色 Gank好手 低生命值 高机动性 拥有爆发或高持续的伤害 拥有逃跑手段 斗士 堵路机制 追逐好手 擅长近距离战斗 拥有控制手段 拥有高持续的伤害 护卫 能有效地防御来自敌方的攻击 能力都集中在撤退和阻挠进攻的方法，而非直接作战。 狙击手 长距离攻击，短冷却时间 善于放风筝 不善于近战 有加速手段 开团手 擅长打团，不擅长独战 拥有高风险高回报的特性 拥有非常强大的控制手段 医师 有限的攻击力 无逃生手段 需要被保护 拥有治疗能力 毒师 拆塔好手 拥有能够立即杀死多个目标的能力，通常冷却时间较短 辅助 不适合直接战斗 万金油 需要被保护 拥有改变团队的能力 坦克 高生命值 减伤好手 适合打头阵 不善于追逐 技能 在《王牌英雄》，每个英雄拥有四个技能，它们分别是：主动技能1、主动技能2、普通攻击、跳跃。我们接下来便以谢里夫·龙星为示范： 主动技能1 主动技能2 普通攻击 跳跃 技能还可以在商店支付太阳能进行强化，如下图： 属性 在《王牌英雄》，属性和一般游戏不同：它明确分为自身属性和技能属性。自身属性即单位本身常驻的属性，而技能属性则为描述技能作用的参数。 自身属性一般来说都是隐藏的，每个英雄的自身属性都是事先决定，这意味着这并不是一款需要属性养成的游戏，你并不需要太关注属性方面的事情，但你仍可在商店里进行一些强化。 以下是属性一览： 自身属性 生命值 生命值是指死亡前可以采取的伤害量。换言之，到了0就会死。 质量 质量是指单元推动或被另一单元推动的能力，例如近战兵的质量就很低（可以被推后）。 移动速度 移动速度即单位移动时的速度。 太阳能获取 每段时间获取太阳能的数额。 太阳能 用于商店购买强化技能。 技能属性 攻击速度 攻击速度决定每次攻击之间的时间间隔，一般存在于普通攻击。 攻击速度以一个数值的形式体现，结算到具体的时间需要/60。 攻击范围 攻击范围指子弹的行进距离。 攻击范围对非发射子弹类技能无效。 技能范围 俗称AOE，泛指那些覆盖一个区域的技能效果。 冷却时间 冷却时间是指技能可以再次使用之前必须经过的时间段。 每个技能都有自己的冷却时间，普通攻击和跳跃不存在冷却时间。 控制时间 控制时间是指使敌方停止/阻碍行动的时间段。 控制的表现手法多样。 持续伤害 俗称DOT，泛指随时间慢慢伤害目标的效果。 飞行 飞行是无限跳跃或能够永远留在空中的能力。 治疗 治疗是指恢复目标生命值的能力。 隐形 隐形是使目标完全不可见的状态效应。当隐形的单位使用能力或自动攻击时，或者在一段时间后，隐形会消失。 生命偷取 生命偷取是一种特殊的伤害，它在击中敌人后生效。 生命偷取可以是基于百分比或固定量。 护盾 护盾是给予英雄保护的能力，在存在护盾时，受到攻击后会优先磨损护盾。 反射 反射是一种使敌人子弹反射回攻击者的机制。同时因为反射了，所以英雄不会受伤。 加速 一段时间内获得移动速度。 后记 《王牌英雄》英雄的特性分类值得思考，技能属性的设计更是优秀，运用这种思路，制作技能将会简单很多。 但是在技能设计和人设方面就不太合我胃口，尤其是技能方面，由于技能数量和深度不足的原因便显得比较单调，就算拥有强化途径但也感觉稍逊一筹，也许在这方面应该可以做得更好。 战斗前言 《王牌英雄》在战斗上拥有不少细节值得研究，而有些东西不方便插入到其他章节中，便集中到本章讨论。 攻击类型 《王牌英雄》的攻击方式分为两种：单一攻击和群体攻击。单一攻击表现为击中一个敌人后便会结束，忽略其他敌人。而群体攻击则不然，会攻击范围内所有敌人。 打击特征 《王牌英雄》属于轻动作游戏，它不是那种击中敌人后敌人便会陷入硬直，以连招为乐的动作游戏。它似乎连硬直和浮空动作也不具备，尽管会有类似的效果表现。就连打击特效，也仅仅是近战角色才有。平常的打击特征为被击者出现黄色遮罩，以及配合伤害数字来确定被击中，更别提Hit Stop了。因此使得《王牌英雄》的动作性并不高，它主要以不断跳跃位置的游击战为特色。 幸运的是，《王牌英雄》还是具备了基本的战斗音效，所以总体来说还是不成问题的，只是缺乏了点动作性而已。 BUFF 《王牌英雄》虽然存在BUFF系统，但并没有展示BUFF的UI，只存在BUFF特效和触发提示，如图： 障碍 《王牌英雄》的障碍形式区域制，只要单位能过跨越障碍就能通过，如通过跳跃穿过敌方士兵，但若同时撞上在空中的地方英雄则会无法继续前行，被迫降落。 至于降落点本身就有障碍该如何处理，这一点尚不明确。 后记 《王牌英雄》的战斗系统在我看来并不讨喜，主要原因为总体攻击距离太短，加上依赖跳跃的地形，使得直接触发战斗的成本提高，当然好这口的人估计会很喜欢。 能够在跳跃中使用大部分技能的设计还是很不错的，给人一种空战的感觉。类似的设计还有多角度攻击，不过这个是远程英雄的专利，对于近战英雄并不友好，我认为这个设计已经影响到了平衡性，因为本身能够快速接近敌人手段并不多。 后记 《王牌英雄》从游戏的角度上让我评分的话，10分里面只能打个4分：它不是我的菜，无论从战斗、技能、还是人设来看，都是如此。 但它对我而言的意义在于：提供了一款横版MOBA动作游戏的示范，它还是一款成熟的横版MOBA模型，使我得到了不少启发，也使我明白哪些部分应该加以改善。本次《王牌英雄》的研究报告，就此结束。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在Mac平台使用GitHub和Hexo搭建博客]]></title>
      <url>%2F2017%2F02%2F26%2Fbuild_bolg%2F</url>
      <content type="text"><![CDATA[欢迎参与讨论，转载请注明出处。 前言 在整这个博客时遇到了不少坑，正适合作为此博客的第一篇正文。另外本文会随博客的调整而更新，可保持关注。 本次的博客搭建平台为Mac OS X 11.6，但总体来说用到系统本身特性的地方很少，所以其他系统的使用者亦可参考。 本文涉及到一些软件的相关知识，如果你不了解它们，请先去了解一番。 如果你已是GitHub用户并且创建了GitHub Pages仓库，你可以跳过部署GitHub。 如果你已安装Git、NPM和Node.js，或非Mac OS平台，你可以跳过安装前置软件，但非Mac OS平台的用户请自行解决前置软件的问题。 部署GitHub前言 本次博客的发布网站是隶属于GitHub的GitHub Pages仓库，通过把网站文件存放到这种仓库里，你便可以利用GitHub提供给你的外链访问它。 声明：以下部分内容转载自铁锚的创建GitHub技术博客全攻略。 注册账号 前往GitHub官网，参考下图输入账号、邮箱、密码，然后点击注册按钮。 初始设置 注册完成后，选择Free免费账号完成设置。 验证邮箱 请打开你的邮箱，查看发送给你的确认邮件。你需要验证邮箱后，后面生成的个人主页才会被接受和发布。 创建页面仓库 前往创建仓库，参考下图。 仓库的名字需要和你的账号对应， 如 tiemaocsdn.github.io。 输入基本信息，然后点击创建仓库。 后记 当你创建完页面仓库后，此时你的个人页面https://username.github.io/已经创建完成（username即你的GitHub用户名，下同），虽然还是空无一物，不过你已可以进行下一步了。 安装前置软件前言 在进行安装核心软件之前，你需要先准备好其所依赖的软件。包括Git、NPM和Node.js。 安装Homebrew 在Mac OS下，你可以选择通过Homebrew来进行许多服务类软件的安装（这样会方便很多），在其他系统下也有类似的替代方案。 打开终端, 输入以下脚本。 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 等待安装完成后，在终端输入brew进行调试，如无报错则可继续。 通过Homebrew安装其余软件 如果你不用Homebrew，那么请通过其他方式进行下载并安装（例如官网）。以下演示使用Homebrew安装他们，一样是通过终端输入，需要按照顺序。 123brew install gitbrew install nodebrew install npm 与Homebrew一样，安装完成后，你可以尝试依次在终端输入git、node、npm进行调试，如无报错则可继续。 后记 如果你觉得Homebrew的速度很慢，那么你可以考虑选择更换镜像。请通过搜索引擎寻找相关资料。 安装Hexo及主题前言 本次博客的框架源自Hexo，我们通过使用它来搭建出博客。Hexo基于Node.js，所以我们可以使用NPM来安装它，这在其他系统下也是一样的。 使用NPM安装 与之前一样，在终端输入以下内容（选择其中之一），你的网络如果不是很好的话，可以选择方案二（通过淘宝镜像进行下载）。 12npm install -g hexo-clinpm install -g hexo-cli --registry=https://registry.npm.taobao.org 新建博客工程 接下来你需要在终端切换到你觉得合适的目录下通过Hexo新建你的博客工程（也可以不管，只要你知道当前终端目录的所在）。例如（目录可通过拖动文件夹到终端指定）： 12cd /Users/Username/Documents/Bolghexo init 经过一段时间后便会在Bolg文件夹下新建一堆文件，如下图这般，如无报错则可继续。 关于博客主题 在你新建博客工程后仍需要选择一个主题(theme)应用到博客里，主题文件位于博客工程下的themes目录，默认便存在一款名为landscape的主题。你可以选择从Hexo官网的主题专栏下载其他主题。 以下便以本博客所使用的NexT为范例进行演示。接下来的内容将会参考这里。 安装NexT主题 前往发布页面选择你想要的版本（下图0.4.0版仅为示范），下载解压后获得Next主题，然后将其以文件夹的形式放到themes目录下。 贴士：你可以考虑像我这样把解压后的文件夹名称更改为next，这样会更清晰。 后记 关于主题的选择其实远不止官网所刊，关于这些方面的你可以多去寻觅甚至自己动手丰衣足食！ 部署博客前言 接下来我们要确立一个概念：在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于博客工程目录（根目录）下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件。 启用主题并调试 打开站点配置文件，找到theme字段，并将其值更改为next（主题文件夹名称）。 到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。 首先打开终端并切换目录到博客工程，输入hexo server --debug进行网站调试。当命令行输出中提示出： INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问http://localhost:4000，检查站点是否正确运行。 当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse。 现在，你已经成功安装并启用了 NexT 主题。你现在可以在终端按下Ctrl+C结束调试，下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。 个性化设置 打开站点配置文件，你可以修改以下字段来实现： language 设置成你所需要的语言，例如：language: zh-Hans 目前 NexT 支持的语言如以下表格所示： avatar 设置成头像的链接地址，例如：avatar: http://example.com/avatar.png 其中，头像的链接地址可以是： author 设置author为你的昵称，例如：Musoucrow 打开主题配置文件，你可以修改以下字段来实现： scheme Scheme是NexT提供的一种特性，借助于Scheme，NexT为你提供多种不同的外观。同时，几乎所有的配置都可以 在Scheme之间共用。目前NexT支持三种Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 搜索scheme关键字。 你会看到有三行scheme的配置，将你需用启用的scheme前面注释#即可。 menu 设定菜单内容，可通过解除几个自带项的注释#来开启栏目。 也可以自己进行新增，格式为item name: link。 item name是一个名称，这个名称并不直接显示在页面上，它将用于匹配图标以及翻译。 NexT 默认的菜单项有（标注！的项表示需要手动创建这个页面）： social social可让博客的侧栏里的角色介绍栏目下增加链接项（可添加多个），你可以这样设置： 博客的具体效果为： 新建标签和分类栏目 回到终端，仍然是博客工程目录下，依次输入以下两句： 12hexo new page tagshexo new page categories 这样便创建好了标签和分类栏目的页面文件，但仍需要做一些处理。 打开source/categories/index.md和source/tags/index.md，分别修改成： 123456---title: categoriesdate: 2017-02-25 21:43:34comments: falsetype: &quot;categories&quot;--- 123456---title: tagsdate: 2017-02-25 22:40:53comments: falsetype: &quot;tags&quot;--- 你现在可以再次调试一下看看效果，不出意外的话，已经实现了标签和分类栏目。记得要先结束之前的网站调试（在调试终端下按Ctrl+C），再重新进行。 后记 静态站点拥有一定的局限性，因此我们需要借助于第三方服务来扩展站点的功能。 以下是 NexT 目前支持的第三方服务，你可以根据你的需求集成一些功能进来。详情查看 发表帖子前言 博客的帖子是Markdown格式（后缀名为.md），如果你尚未熟悉，请去进行专门的学习。 新建帖子 在终端、博客工程目录下输入：hexo new post test1以创建一个标题名为test1的帖子。你可以在source/_posts/目录下看到它。 在文件顶部有着与source/categories/index.md和source/tags/index.md相同格式的配置，该类配置可拥有如下属性（comments属性必须保证已经安装了第三方服务后才能生效）： 123456title: 文章的标题date: 创建日期，例如(2017-02-26 00:54:28)updated: 修改日期comments: 是否开启评论(true or false)type: 标签，多个时表示为([a, b, c])categories: 分类 修改创建格式 使用命令创建的帖子文件的格式，系源自于scaffolds/post.md，你可以通过修改它来达到帖子模板化的效果，例如： 后记 帖子文件的本质就是从模板产生的克隆品，所以也可以自己手动新建文件。同理删除帖子也只需要直接删除文件即可，无需通过网站管理之类的手段，非常方便。 发布网站前言 发布网站的原理其实就是生成网站文件夹并传输到GitHub上对应的仓库https://github.com/username/username.github.io，然后便可通过https://username.github.io进行访问。 上传部署 在终端输入npm install hexo-deployer-git --save，安装完毕后打开站点配置文件，添加deploy字段。 1234deploy: type: git repository: http://github.com/username/username.github.io.git branch: master 注意事项 是http而非https。 在旧版(&lt;3.0)的Hexo里是github而非git。 username即你的GitHub用户名，实际以你自己创建的仓库地址为准。 生成并上传 在终端、博客工程目录下输入：hexo generate，完成后便会发现新增了public目录。那便是网站文件夹，用于上传到GitHub仓库。 接下来再输入hexo deploy，将网站文件夹上传到GitHub仓库。以后在本地做了修改后，便进行这两个操作将网站生成并上传即可。 后记 有时候把一些配置文件搞炸的时候或者上传有问题时，可以使用hexo clean来尝试修复。 如果觉得GitHub的传输速度过慢，可考虑修改host尝试能否增速，以下是一个江湖偏方： 151.101.88.249 github.global.ssl.fastly.Net]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[终于整了个博客]]></title>
      <url>%2F2017%2F02%2F26%2Ffirst%2F</url>
      <content type="text"><![CDATA[一直以来都没有这么做，一来是觉得自己修炼不足无甚可写，二来是尚未具备分享意识。 然时境过迁，现在也到了2017年。算算时间，已经是我接触游戏开发的第五年了。经过了这么多年，怎么说也算有点积累，也有不少东西想和大家分享探讨。 今后我将在这个博客分享各个方面的心得体会，欢迎各位前来交流，互相学习，共同成长。]]></content>
    </entry>

    
  
  
</search>
